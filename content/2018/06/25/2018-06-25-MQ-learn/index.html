<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="keywords" content="">
  
    <link rel="icon" href="">
  
    
  <title>消息队列学习笔记 | 水货程序员的笔记</title>
  <link rel="stylesheet" href="/content/style.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.20/jquery.fancybox.min.css" />
</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/content/">
      <span>水货程序员的笔记</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/content/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/content/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/content/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/content/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>消息队列学习笔记</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2018年06月25日</time>
            
              | <i class="fa fa-folder-open-o" aria-hidden="true"></i> 
  <div class="article-category">
    <a class="article-category-link" href="/content/categories/MQ/">MQ</a>
  </div>



            
            
          </div>
          <h3 id="消息队列的使用场景"><a href="#消息队列的使用场景" class="headerlink" title="消息队列的使用场景"></a>消息队列的使用场景</h3><ul>
<li>解耦</li>
<li>最终一致性</li>
<li>广播</li>
<li>错峰与流控</li>
</ul>
<h3 id="MQ的实现原理"><a href="#MQ的实现原理" class="headerlink" title="MQ的实现原理"></a>MQ的实现原理</h3><p>mq的实现其实本质上还是生产者发送RPC请求给”消息队列服务端”,然后消息队列服务端将数据进行存储，在适当的时候消息队列服务端发送RPC请求给消费端，消费端最后发送RPC请求给消息队列服务端完成消费确认。<br>因此：<strong>消息队列可以简单的理解为是3次RPC请求加上暂存</strong></p>
<h3 id="activeMQ实战"><a href="#activeMQ实战" class="headerlink" title="activeMQ实战"></a>activeMQ实战</h3><h4 id="activeMQ的安装"><a href="#activeMQ的安装" class="headerlink" title="activeMQ的安装"></a>activeMQ的安装</h4><ul>
<li>本地下载activeMQ</li>
<li><p>服务器如果没有上传命令，需要按照上传和下载命令</p>
<pre><code>yum install -y lrzsz
</code></pre></li>
<li><p>将本地的文件上传至服务器</p>
</li>
<li><p>解压</p>
<pre><code>tar zvxf apache-activemq-5.15.4-bin.tar.gz
</code></pre></li>
<li><p>启动</p>
<pre><code>cd /app/apache-activemq-5.15.4
./bin/activemq start
</code></pre></li>
<li><p>访问控制台</p>
<pre><code>http://192.168.182.129:8161/admin
</code></pre></li>
</ul>
<p><strong>注意</strong></p>
<pre><code>activemq依赖于jdk，需要提前在服务器上安装好jdk
</code></pre><h4 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h4><ul>
<li>JMS是什么</li>
</ul>
<p>JMS ： Java Message Serivice ,Java 消息服务，是JavaEE中的一种技术</p>
<ul>
<li>JMS规范</li>
</ul>
<p>JMS定义了JAVA中访问消息中间件的接口,并没有给予实现实现JMS接口的消息中间件称为JMS Provider，例如：ActiveMQ</p>
<ul>
<li>JMS provider: 实现JMS接口和规范的消息中间件</li>
<li><p>JMS message: JMS的消息，JMS消息由以下三部分组成：</p>
<pre><code>1：消息头
2：消息属性
3：消息体：封装具体的消息数据
</code></pre></li>
<li><p>JMS producer: 消息生产者，创建和发送JMS消息的客户端应用</p>
</li>
<li><p>JMS consumer: 消息消费者，接收和处理JMS消息的客户端应用，消息的消费可以采用以下两种方式之一：</p>
<pre><code>1：同步消费：通过调用消费者的receive方法从目的地中显示提取消息,receive方法可以一直阻塞到消息到达。
2：异步消费：客户端可以为消费者注册一个消息监听器，以定义在消息到达时所采取的动作
</code></pre></li>
<li><p>JMS domains: 消息传递域，JMS规范中定义了两种消息传递域：</p>
<pre><code>1：点对点：PTP,
   每个消息只能有一个消费者
   消费者和生产者之间没有时间上的相关性。
2：发布/订阅 ： pub/sub
   每个消息可以有多个消费者
   生成者和消费者有时间上的相关性，只能消费自其订阅之后的消息。
   JMS规范允许客户端创建持久订阅，持久订阅可以消费订阅之前的消息
</code></pre></li>
<li><p>Connection factory: 连接工厂,用来创建连接对象，以连接到JMS provider</p>
</li>
<li>JMS Connection: 封装了客户端与JMS提供者之间的一个虚拟的连接</li>
<li><p>JMS Session: 是生产和消费消息的一个单线程上下文</p>
<pre><code>会话用于创建消息生产者，消费者，消息等。会话提供了一个事务性的上下文，
在这个上下文中，一组发送和接收被组合到了一个原子操作中。
</code></pre></li>
<li><p>Destination: 消息发送到的目的地</p>
</li>
<li>Acknowledge: 签收</li>
<li><p>Transaction: 事务</p>
</li>
<li><p>JMS消息类型</p>
<pre><code>TextMessage
MapMessage
BytesMessage
StreamMessage
ObjectMessage
</code></pre></li>
<li><p>消息的接收确认</p>
<pre><code>JMS消息只有在被确认之后，才认为已经被成功的消费了。
消息的成功消费包括三个阶段：客户端接收消息，客户端处理消息和消息被确认
在事物性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式，参数有以下三个可选值：
Session.AUTO_ACKNOWLEDGE:客户端receive方法返回或者MessageListener.onMessage方法成功返回的时候，会话自动确认
Session.CLIENT_ACKNOWLEDGE:客户端通过调用acknowledge方法确认消息，确认一个消息，将自动确认所有已被会话消费的消息
Session.DUPS_ACKNOWLEDGE: 会话迟钝的确认消息的提交，可能会导致一些重复的消息
</code></pre></li>
<li><p>消息持久化</p>
<pre><code>JMS支持以下两种消息提交模式：
PERSISTENT：指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失
NON_PERSISTENT: 不要求JMS provider持久保存消息
</code></pre></li>
</ul>

        </section>
    </article>
    
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#消息队列的使用场景"><span class="toc-number">1.</span> <span class="toc-text">消息队列的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MQ的实现原理"><span class="toc-number">2.</span> <span class="toc-text">MQ的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#activeMQ实战"><span class="toc-number">3.</span> <span class="toc-text">activeMQ实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#activeMQ的安装"><span class="toc-number">3.1.</span> <span class="toc-text">activeMQ的安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JMS"><span class="toc-number">3.2.</span> <span class="toc-text">JMS</span></a></li></ol></li></ol>
        </div>
    </div>
    
  </aside>
</main>



  <footer>
  <div class="copyright">
    <div>
      &copy; 2018 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/content/lib/in-view.min.js"></script>
<script src="/content/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.20/jquery.fancybox.min.js"></script>


</body>
</html>
