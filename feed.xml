<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2B程序员的笔记</title>
    <description></description>
    <link>http://colorful.ren/</link>
    <atom:link href="http://colorful.ren/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 26 Sep 2016 18:41:32 +0800</pubDate>
    <lastBuildDate>Mon, 26 Sep 2016 18:41:32 +0800</lastBuildDate>
    <generator>Jekyll v3.0.0</generator>
    
      <item>
        <title>mysql的数据备份和恢复</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#mysql&quot; id=&quot;markdown-toc-mysql&quot;&gt;mysql的二进制日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据库的备份和恢复是每个DBA必须掌握的技能。作为开发人员来说，适当的了解，也是有必要的。曾经我就遇到过一个面试官问过我：是否会进行数据库备份和恢复，什么是热备份，什么是冷备份。当然，我不能说这是DBA的工作，只能怪自己学的不够广。当学会了数据库的备份和恢复，再次使用数据库的时候，视野就更开阔了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;mysql&quot;&gt;mysql的二进制日志&lt;/h3&gt;

&lt;p&gt;说起mysql的备份和恢复，就必须说mysql的二进制日志，它记录的是所有mysql数据库发生变更的信息，因此对数据库非常重要&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;主要作用有以下几个方面&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;可以用于数据库基于时间点的还原&lt;/li&gt;
      &lt;li&gt;可以用来分析数据库发生变更的情况，比如程序程序bug导致数据库数据更改等。&lt;/li&gt;
      &lt;li&gt;二进制日志还可以用来重建数据库&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二进制日志功能配置&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;开启bin_log日志功能,在my.cnf中修改，在[mysqld]下增加:&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; log-bin=/tmp/mysql-log
 binlog_format=mixed
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看二进制日志功能是否开启&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; show variables like &#39;%log_bin%&#39;;
 +---------------------------------+----------------------+
 | Variable_name                   | Value                |
 +---------------------------------+----------------------+
 | log_bin                         | ON                   |
 | log_bin_basename                | /tmp/mysql-log       |
 | log_bin_index                   | /tmp/mysql-log.index |
 | log_bin_trust_function_creators | OFF                  |
 | log_bin_use_v1_row_events       | OFF                  |
 | sql_log_bin                     | ON                   |
 +---------------------------------+----------------------+
 6 rows in set
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看二进制文件的情况&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; show master logs;
 +------------------+-----------+
 | Log_name         | File_size |
 +------------------+-----------+
 | mysql-log.000001 |       143 |
 | mysql-log.000002 |       562 |
 +------------------+-----------+
 2 rows in set
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;或者&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; show binary logs;
 +------------------+-----------+
 | Log_name         | File_size |
 +------------------+-----------+
 | mysql-log.000001 |       143 |
 | mysql-log.000002 |       562 |
 +------------------+-----------+
 2 rows in set
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换二进制文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; flush logs;
 Query OK, 0 rows affected

 mysql&amp;gt; show binary logs;
 +------------------+-----------+
 | Log_name         | File_size |
 +------------------+-----------+
 | mysql-log.000001 |       143 |
 | mysql-log.000002 |       609 |
 | mysql-log.000003 |       120 |
 +------------------+-----------+
 3 rows in set
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除或者初始化二进制文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; reset master;
 Query OK, 0 rows affected
	
 mysql&amp;gt; show binary logs;
 +------------------+-----------+
 | Log_name         | File_size |
 +------------------+-----------+
 | mysql-log.000001 |       120 |
 +------------------+-----------+
 1 row in set
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定二进制日志失效期&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; show variables like &quot;%expire%&quot;;
 +--------------------------------+-------+
 | Variable_name                  | Value |
 +--------------------------------+-------+
 | disconnect_on_expired_password | ON    |
 | expire_logs_days               | 0     |
 +--------------------------------+-------+
 2 rows in set

 mysql&amp;gt; set global  expire_logs_days=5;
 Query OK, 0 rows affected
	
 mysql&amp;gt; show variables like &quot;%expire%&quot;;
 +--------------------------------+-------+
 | Variable_name                  | Value |
 +--------------------------------+-------+
 | disconnect_on_expired_password | ON    |
 | expire_logs_days               | 5     |
 +--------------------------------+-------+
 2 rows in set
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二进制日志的格式的查看和格式介绍,这里仅做了解,有三种&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; show variables like &#39;%format%&#39;;
 +--------------------------+-------------------+
 | Variable_name            | Value             |
 +--------------------------+-------------------+
 | binlog_format            | MIXED             |
 | date_format              | %Y-%m-%d          |
 | datetime_format          | %Y-%m-%d %H:%i:%s |
 | default_week_format      | 0                 |
 | innodb_file_format       | Antelope          |
 | innodb_file_format_check | ON                |
 | innodb_file_format_max   | Antelope          |
 | time_format              | %H:%i:%s          |
 +--------------------------+-------------------+
 8 rows in set

 Row : 日志中会记录成每一行数据被修改的形式，然后在 slave 端再对相同的数据进行修改
 Statement ： 每一条会修改数据的 SQL 都会记录到 master 的 bin-log 中。slave 在复制的时候 SQL 进程会解析成和原来 master 端执行过的相同的 SQL 再次执行。
 Mixed : MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 statement 和 row 之间选择一种,相当于前两种的混合。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看二进制日志文件的内容&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; # mysqlbinlog mysql-log.00000

 SET TIMESTAMP=1474882546/*!*/;
 insert into t select * from t
 /*!*/;
 # at 739
 #160926  2:35:46 server id 1  end_log_pos 770 CRC32 0x45bf6de6 	Xid = 98
 COMMIT/*!*/;
 # at 770
 #160926  2:35:47 server id 1  end_log_pos 849 CRC32 0xdcad682e 	Query	thread_id=1	exec_time=0	error_code=0
 SET TIMESTAMP=1474882547/*!*/;
 BEGIN
 /*!*/;
 # at 849
 #160926  2:35:47 server id 1  end_log_pos 952 CRC32 0x596b7cf9 	Query	thread_id=1	exec_time=0	error_code=0
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;仔细观察会发现，这里记录了数据库的每一次查询和修改过程，就像数据库的变更记录一样，难怪可以用来恢复数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 26 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/mysql/2016/09/26/mysql-log.html</link>
        <guid isPermaLink="true">http://colorful.ren/mysql/2016/09/26/mysql-log.html</guid>
        
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>全栈还是专攻，这是一个问题</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;经常会浏览一下招聘网站，一方面，可以了解现在的市场行情，另一方面，可以了解目前行业使用的技术都有什么，具体有些什么要求，这是我根据我浏览很多信息之后的一点感悟&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;以下是我在某job上截取的一段用人单位的提出的技能要求:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、计算机相关专业本科及以上学历，3年以上Java开发工作经验；
2、熟悉MVC设计模式，熟悉Java领域常用的开源框架，如Spring、Struts、Ibatis、Hibernate等；
3、熟悉面向对象编程思想和设计模式；
4、熟悉多线程编程，熟悉socket编程、WebService接口技术；
5、熟悉MINA、Volley等网络通信应用框架，有MINA开发经验者优先。
6、熟悉Oracle、MySql等数据库，并有开发经验；
7、熟悉linux/UNIX等操作系统，了解Shell；
8、较强的表达和沟通能力，善于团队合作；
9、互联网金融开发经验者优先，有大容量、高性能、高可用、分布式、架构设计经验者优先；
10、熟悉hadoop/spark等大数据应用框架优先
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;这是大部分互联网公司开出的技能要求，有的甚至更多。那么问题来了, 业内的人都知道，任何一项技术，要想熟练掌握，是需要沉淀的，有一个广为人知的说法叫一万小时理论也就是说一项技术需要熟练掌握需要至少刻意练习10000小时，也就是3年&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;回到上面的技能要求上，上面的任何一项技能都可以单独拎出来，写成一本书，够研究好几年的，有些技术甚至够研究一辈子了，比如上面提到的：&lt;strong&gt;&lt;em&gt;大容量、高性能、高可用、分布式、hadoop/spark&lt;/em&gt;&lt;/strong&gt;，先不说其他的，单单能同时掌握这些，就已经属于稀有天才了。&lt;/p&gt;

&lt;p&gt;互联网的后端技术都是围绕两个主题展开的&lt;em&gt;大数据量&lt;/em&gt;和&lt;em&gt;高并发&lt;/em&gt;。精通其中一项基本可以在职场纵横天下了。&lt;/p&gt;

&lt;p&gt;既然如此，用人单位为什么要提出如此苛刻的要求呢？我认为原因主要有以下几个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一线城市人力成本急剧上升，尤其是以信息技术为代表的IT行业&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 一线城市的房价暴涨，想留住人才，薪资往往是最具有吸引力的，所以出现了现在大家知道的一线开发人员动辄月薪数万，因此用人单位希望招到能力强的人，一个人顶几个用，也就是说希望自己的员工是个多面手。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;技术更新换代快，系统质量和用户体验要求越来越高&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 用户对产品不断提出更高的要求，更好的用户体验。
 对这些功能最好的保证就是高水平的开发人员。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用人单位需要的是全而专的人&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 认真开用人单位的用人要求，大部分都是要求&quot;熟悉&quot;，并没有要求&quot;精通&quot;。
 因此有理由相信用人单位需要的是视野开阔，对多种技术均有涉猎，但又能精通一两种的人
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;经过以上的分析，也知道以后自己的道路该怎么走了，那就是，既要要有知识的广度，也要有专业的深度。我认为，深度比广度重要。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 26 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/fulin/2016/09/26/job.html</link>
        <guid isPermaLink="true">http://colorful.ren/fulin/2016/09/26/job.html</guid>
        
        
        <category>fulin</category>
        
      </item>
    
      <item>
        <title>mysql中使用explain来分析Sql语句的性能</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;语法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;SQL优化的基本思路就是，先找到性能差的语句，然后找到性能差的原因，然后优化。当我们找到目标SQL之后，可以使用explain来分析SQL语句的执行过程，说白了就是看看这个语句的执行计划，找到性能瓶颈。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;语法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;explain &amp;lt;语句&amp;gt;  //explain是专门分析select等查询语句的执行计划的
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;例子&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;执行以下sql语句，看一下它的执行计划(&lt;em&gt;这是一个比较复杂的查询了，比较典型&lt;/em&gt;)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; EXPLAIN 
     SELECT
         o.order_id,
         o.order_sn,
         o.parent_order_sn,
         o.outer_id,
         e.pay_work_code,
         o.add_time,
         o.order_source,
         p.product_id,
         p.product_num,
         p.product_name,
         p.sell_num,
         p.sell_price,
         t.cacle_time,
         t.order_id
     FROM
         gshop_order o
     LEFT JOIN gshop_order_product p ON o.order_id = p.order_id
     LEFT JOIN gshop_order_ext e ON o.order_id = e.order_id
     LEFT JOIN (
         SELECT
             g1.order_id,
             g1.order_sn,
             g1.parent_order_sn,
             g1.outer_id,
             g2.from_status,
             g2.add_time AS cacle_time,
             g2.to_status,
             count(*) AS nums
         FROM
             gshop_order g1
         LEFT JOIN gshop_order_log g2 ON g1.order_id = g2.order_id
         WHERE
             g1.order_belong = 3
         AND g1.order_status = 13
         AND g1.sfv_download = 0
         AND (
             g1.order_source = 22
             OR g1.order_source = 26
         )
         AND g2.from_status = 5
         AND g2.to_status = 13
         AND g2.add_time &amp;gt; 1472610864
         GROUP BY
             g1.order_id
     ) t ON o.order_id = t.order_id
     WHERE
         t.order_id IS NOT NULL
     ORDER BY
         t.cacle_time DESC
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行结果如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; +----+-------------+------------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+---------+----------------------+------+-----------------------------+
 | id | select_type | table      | type   | possible_keys                                                                                                                                                 | key         | key_len | ref                  | rows | Extra                       |
 +----+-------------+------------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+---------+----------------------+------+-----------------------------+
 |  1 | PRIMARY     | &amp;lt;derived2&amp;gt; | ALL    | NULL                                                                                                                                                          | NULL        | NULL    | NULL                 |    2 | Using where; Using filesort |
 |  1 | PRIMARY     | o          | eq_ref | PRIMARY                                                                                                                                                       | PRIMARY     | 4       | t.order_id           |    1 | NULL                        |
 |  1 | PRIMARY     | p          | ref    | idx_orderid                                                                                                                                                   | idx_orderid | 4       | t.order_id           |    1 | NULL                        |
 |  1 | PRIMARY     | e          | eq_ref | order_id                                                                                                                                                      | order_id    | 4       | t.order_id           |    1 | NULL                        |
 |  2 | DERIVED     | g1         | ref    | PRIMARY,idx_userid,idx_ordersn,idx_addtime_status,idx_areanumber,idx_couponid,idx_parentorderid,idx_parentordersn,idx_paytime_payid,idx_shippingsn,idx_status | idx_status  | 1       | const                |    2 | Using where                 |
 |  2 | DERIVED     | g2         | ref    | idx_orderid                                                                                                                                                   | idx_orderid | 4       | gshop_db.g1.order_id |    1 | Using where                 |
 +----+-------------+------------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+---------+----------------------+------+-----------------------------+
 6 rows in set
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;explain 结果详解&lt;/p&gt;

    &lt;p&gt;看到	explain 出来的结果，相信初学者应该已经懵逼了，面对这种情况，千万不能慌，要沉住气，要相信 &lt;em&gt;“我们的宇宙是存在规律的，并且规律是可以被认识的”&lt;/em&gt;，其实就是说，所有的技术，只要认真学，都是可以学会的，下面对explain结果的每一个字段的含义进行解释&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; id
     SQL执行顺序的标识，执行顺序是从大到小，例子中最先执行的是id为2的，也就是说是从下往上执行的。

 select_type
     就是select的类型,有这么几种：
     SIMPLE ： 简单SELECT(不使用UNION或子查询等）
     primary ： 最外层的select，在有子查询的语句中，最外层的select就是primary
     union : union语句的第二个或者说是后面那一个
     DEPENDENT UNION : UNION中的第二个或后面的SELECT语句，取决于外面的查询
     UNION RESULT : UNION的结果
     SUBQUERY : 子查询中的第一个SELECT
     DEPENDENT SUBQUERY : 子查询中的第一个SELECT，取决于外面的查询
     DERIVED : 派生表的SELECT(FROM子句的子查询)

 table
     显示这一行的数据是关于哪张表的.有时不是真实的表名字,看到的derivedx(x是个数字,我的理解是第几步执行的结果)

 type
     这列很重要,显示了连接使用了哪种类别,有无使用索引.从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL
     system : 这是const联接类型的一个特例。表仅有一行满足条件.
     const : 表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const表很快，因为它们只读取一次！const用于用常数值比较PRIMARY KEY或UNIQUE索引的所有部分时
     eq_ref : 对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY。eq_ref可以用于使用= 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。
     ref : 对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。ref可以用于使用=或&amp;lt;=&amp;gt;操作符的带索引的列。
     ref_or_null : 该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。
     index_merge : 该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。
     unique_subquery : 该类型替换了下面形式的IN子查询的ref：
         value IN (SELECT primary_key FROM single_table WHERE some_expr)
         unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。
     index_subquery : 该联接类型类似于unique_subquery。可以替换IN子查询
     range : 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。在该类型中ref列为NULL。当使用=、&amp;lt;&amp;gt;、&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=、IS NULL、&amp;lt;=&amp;gt;、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range
     index : 该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。当查询只使用作为单索引一部分的列时，MySQL可以使用该联接类型。
     ALL ： 对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。

 possible_keys
     possible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询

 key
     key列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。

 key_len
     key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好

 ref
     ref列显示使用哪个列或常数与key一起从表中选择行。

 rows
     rows列显示MySQL认为它执行查询时必须检查的行数。

 Extra
     该列包含MySQL解决查询的详细信息，下面是详细信息
     Distinct ： 一旦MYSQL找到了与行相联合匹配的行，就不再搜索了
     Not exists ： MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行就不再搜索了
     Range checked for each Record（index map:#）： 没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一
     Using filesort www.2cto.com ： 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行
     Using index ： 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候
     Using temporary ： 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上
     Using where ： 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本例的执行计划解读&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

  	sql语句的执行是按照执行计划从下往上执行的，从执行计划可以看出，最先执行的是表连接中的查询，生成临时表与其他表连接查询，其他表都走的是索引，唯独临时表使用的是全表扫描。
</description>
        <pubDate>Fri, 23 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/mysql/2016/09/23/mysql-explain.html</link>
        <guid isPermaLink="true">http://colorful.ren/mysql/2016/09/23/mysql-explain.html</guid>
        
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>mysql中sql优化的思路和原则</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#sql&quot; id=&quot;markdown-toc-sql&quot;&gt;SQL优化的思路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#sql-1&quot; id=&quot;markdown-toc-sql-1&quot;&gt;SQL优化的基本原则&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;索引相关的总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;大部分系统的性能瓶颈都是IO操作，数据库的IO消耗是其中的重要组成部分，SQL语句性能的优化是很有必要的，如果一开始不注意，后期的改动成本是比较大的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;sql&quot;&gt;SQL优化的思路&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1.优化更需要优化的sql；
2.定位优化对象的性能瓶颈：优化前需了解查询的瓶颈是IO还是CPU可通过PROFILING很容易定位查询的瓶颈。
3.明确优化目标；
4.从Explain入手；
5.多使用profile；
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sql-1&quot;&gt;SQL优化的基本原则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;永远用小结果集驱动大结果集&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;From子句中sql解析顺序为从右向左，执行时会以最左边的表为基础表循环与右边表数据做笛卡尔积，所以以小结果集驱动能减少循环次数，从而减少对被驱动结果集的访问，从而减少被驱动表的锁定。&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;尽可能在索引中完成排序&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;排序算法有两种：a.查出排序字段和行指针，排序，再通过行指针获得行数据所需列，返回结果集；b.取出所有排序列数据，在排序缓冲区中排完序直接返回结果集。索引排序是利用索引的有序性对数据排序的。&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;只取出子集需要的colums&lt;/li&gt;
  &lt;li&gt;仅仅使用最有效的过滤条件&lt;/li&gt;
  &lt;li&gt;尽可能避免复杂的Join和子查询&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;索引相关的总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;什么是索引，可以把索引想象成数据库的目录，查找某一样东西之前，先在目录中确定好位置，直奔位置而去，这就是提高查询效率的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;索引的好处&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 提高数据检索效率，降低数据库的IO成本
 降低数据排序成本：要求排序字段和索引键字段一致
 降低数据分组成本：因为分组之前会先排序，同意如果分组字段与索引字段一致，会降低分组消耗的成本。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;索引的弊端&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 索引是独立于基础数据的数据库对象，因此它会占用存储空间
 数据新增、更新会导致索引的同步更新，所以会增加数据新增、更新所消耗的成本
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;否需要创建索引&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 较为频繁的作为查询条件的字段需要创建索引
 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
 更新非常频繁的字段不适合创建索引
 不会出现在where子句中的字段不要创建索引
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;索引语法&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;唯一索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD UNIQUE indexName (column);
  CREATE UNIQUE INDEX indexName ON tableName (column);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;普通索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD INDEX indexName(column);
  CREATE INDEX indexName ON tableName(column);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;主键索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD PRIMARY KEY (column);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;全文索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD FULLTEXT (column);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;组合索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD INDEX indexName(col1,col2,...);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 22 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/mysql/2016/09/22/mysql-update.html</link>
        <guid isPermaLink="true">http://colorful.ren/mysql/2016/09/22/mysql-update.html</guid>
        
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>mysql 基础知识</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#mysql&quot; id=&quot;markdown-toc-mysql&quot;&gt;mysql的安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mysql-1&quot; id=&quot;markdown-toc-mysql-1&quot;&gt;mysql基础信息（[]表示可选）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;大道至简，世间的道理都是相似的……   &lt;br /&gt;
  就比如学东西吧，以前总是东学一点，西学一点。到头来发现什么都会，什么都不精，所以，到头来才明白：少才是多，less is more。数据库，以后就选择mysql了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;mysql&quot;&gt;mysql的安装&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;因为仅做学习使用，这里只讲centos下的 mysql 安装过程，其他环境下的不做过多解释。而且，这里介绍的也是最方便的安装过程，不一定是最好的方式&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;操作系统信息&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Description:		CentOS Linux release 7.2.1511 (Core) 
 Release:		7.2.1511
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首先查看本系统有没有安装 mariadb&lt;/p&gt;

   	$ rpm -qa |　grep -i mariadb    //这里的-i是忽略大小写

    &lt;pre&gt;&lt;code&gt;   mariadb-libs-5.5.44-2.el7.centos.x86_64
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果有安装，则需要卸载(–nodeps意思是如果有依赖关系，则同时卸载掉)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ rpm -e --nodeps mariadb-libs-5.5.44-2.el7.centos.x86_64 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下载mysql的安装包&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ wget http://dev.mysql.com/Downloads/MySQL-5.6/MySQL-server-5.6.21-1.rhel5.x86_64.rpm
 $ wget http://dev.mysql.com/Downloads/MySQL-5.6/MySQL-devel-5.6.21-1.rhel5.x86_64.rpm
 $ wget http://dev.mysql.com/Downloads/MySQL-5.6/MySQL-client-5.6.21-1.rhel5.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装rpm软件包&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ rpm -ivh MySQL-****.rpm 	
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装MySQL-server会报一个错，因为缺少依赖，使用yum安装即可&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ yum install -y libaio
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初始化MySQL及设置密码&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ /usr/bin/mysql_install_db
 $ service mysql start
 $ cat /root/.mysql_secret  #查看root账号密码
 $ mysql -uroot -pAsTsb42   #AsTsb42是看到的密码
 mysql&amp;gt; SET PASSWORD = PASSWORD(&#39;123456&#39;);    #设置密码为123456
 mysql&amp;gt; exit
 $ mysql -uroot -p123456
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;远程登陆用户设置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; use mysql;
 mysql&amp;gt; select host,user,password from user;
 mysql&amp;gt; update user set password=password(&#39;123456&#39;) where user=&#39;root&#39;;
 mysql&amp;gt; update user set host=&#39;%&#39; where user=&#39;root&#39; and host=&#39;localhost&#39;;
 mysql&amp;gt; flush privileges;
 mysql&amp;gt; exit
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改mysql的配置文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ vi /etc/my.cnf.d/my-default.cnf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;加入如下内容：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [client]
 password=123456
 port=3306
 default-character-set=utf8
	
 [mysqld]
 port=3306
 character_set_server=utf8
 character_set_client=utf8
 collation_server=utf8_general_ci
 collation_database=utf8_general_ci
 lower_case_table_names=1
 max_connections=1000
	
 [mysql]
 default-character-set=utf8
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql的默认安装位置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; /var/lib/mysql/               #数据库目录
 /usr/share/mysql              #配置文件目录
 /usr/bin                      #相关命令目录
 /etc/init.d/mysql             #启动脚本
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql的启动和停止&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ service mysql stop
 $ service mysql start
 $ service mysql restart
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置开机自启动&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ chkconfig mysql on
 $ chkconfig --list | grep mysql
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mysql-1&quot;&gt;mysql基础信息（[]表示可选）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DBA和运维同学常用&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; -- 查看mysql版本信息
 select version(); 
		
 -- 查看字符集
 show variables like &#39;%collation%&#39;;
 show variables like &#39;%char%&#39;;	
	
 -- 查看是否打开二进制日志文件的功能	
 show variables like &#39;%log_bin%&#39;;

 -- 查看有哪些数据库	
 show databases;	

 -- 查看数据库中有哪些表			
 show tables from db_name;		

 -- 查看表的字段信息
 show COLUMNS from db_name.table_name

 -- 查看表的信息	
 show table status from db_name;		
	
 -- 查看MySQL本次启动后的运行时间(单位：秒)
 show status like &#39;uptime&#39;;
	
 -- 查看select语句的执行数
 show [global] status like &#39;com_select&#39;;
	
 -- 查看insert语句的执行数
 show [global] status like &#39;com_insert&#39;;
	
 -- 查看update语句的执行数
 show [global] status like &#39;com_update&#39;;
	
 -- 查看delete语句的执行数
 show [global] status like &#39;com_delete&#39;;
	
 -- 查看试图连接到MySQL(不管是否连接成功)的连接数
 show status like &#39;connections&#39;;
	
 -- 查看线程缓存内的线程的数量。
 show status like &#39;threads_cached&#39;;
	
 -- 查看当前打开的连接的数量。
 show status like &#39;threads_connected&#39;;
	
 -- 查看当前打开的连接的数量。
 show status like &#39;threads_connected&#39;;
	
 -- 查看创建用来处理连接的线程数。
 -- 如果Threads_created较大，你可能要增加thread_cache_size值。
 show status like &#39;threads_created&#39;;
	
 -- 查看激活的(非睡眠状态)线程数。
 show status like &#39;threads_running&#39;;
	
 -- 查看立即获得的表的锁的次数。
 show status like &#39;table_locks_immediate&#39;;
	
 -- 查看不能立即获得的表的锁的次数。
 -- 如果该值较高，并且有性能问题，你应首先优化查询，然后拆分表或使用复制。
 show status like &#39;table_locks_waited&#39;;
	
 --查看创建时间超过slow_launch_time秒的线程数。
 show status like &#39;slow_launch_threads&#39;;
	
 --查看查询时间超过long_query_time秒的查询的个数。
 show status like &#39;slow_queries&#39;;
	
 -- 查看慢查询日志功能是否开启
 show variables like &#39;%slow%&#39;;

 -- 多长时间才是慢查询
 show variables like &#39;%long%&#39;;

 -- 设置查询超过1秒就是慢查询
 set session long_query_time=1;

 -- 查看日志信息是输出到数据库还是系统文件(FILE为系统文件)
 show variables like &#39;log_output&#39;;

 -- 查看发生了多少次慢查询
 show global status like &#39;Slow_queries&#39;;

 -- 将所有没有使用到索引的sql语句都记录到慢查询日志中
 set global log_queries_not_using_indexes = true;

 -- 查看数据库文件的路径
 show variables like &quot;%datadir%&quot;;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速建立一张一模一样的表，并插入数据&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; create table t as select * from information_schema.tables；
 mysql&amp;gt; insert into t select *  from t;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 21 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/mysql/2016/09/21/mysql.html</link>
        <guid isPermaLink="true">http://colorful.ren/mysql/2016/09/21/mysql.html</guid>
        
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>plantUML的使用</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#graphviz&quot; id=&quot;markdown-toc-graphviz&quot;&gt;Graphviz的使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;经常需要画一些图，比如类图，时序图，用例图等，最近接触到一款有趣的工具，是eclipse的一个插件:plantUML。这里只记录最基础的地方，以后再来完善&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;安装&lt;/h3&gt;
&lt;p&gt;直接访问 &lt;strong&gt;&lt;a href=&quot;http://plantuml.com/&quot;&gt;plantUML官网&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;问题&lt;/h3&gt;
&lt;p&gt;安装好插件之后，此时只能使用plantUML画一些时序图，并不能从类文件直接生成类图，这时候还需要安装和配置一个十分牛*的画图工具： &lt;strong&gt;&lt;a href=&quot;http://www.graphviz.org/&quot;&gt;Graphviz&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;graphviz&quot;&gt;Graphviz的使用&lt;/h3&gt;
&lt;p&gt;仅仅使用Graphviz就已经可以画图了，直接使用Graphedit.exe程序就可以画图了，具体参照官网。&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Sep 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/java/2016/09/20/plantuml.html</link>
        <guid isPermaLink="true">http://colorful.ren/java/2016/09/20/plantuml.html</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Object的equals和hashCode和clone方法</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#equals&quot; id=&quot;markdown-toc-equals&quot;&gt;equals方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#hashcode&quot; id=&quot;markdown-toc-hashcode&quot;&gt;hashCode方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#clone&quot; id=&quot;markdown-toc-clone&quot;&gt;clone方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Object类是Java中其他所有类的祖先，没有Object类Java面向对象无从谈起。作为其他所有类的基类，Object具有哪些属性和行为，是Java语言设计背后的思维体现。
Object类位于java.lang包中，java.lang包包含着Java最基础和核心的类，在编译时会自动导入。Object类没有定义属性，一共有13个方法,这里我重点记录3个方法：equals,hashCode,clone，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;equals&quot;&gt;equals方法&lt;/h3&gt;
&lt;p&gt;==与equals在Java中经常被使用，大家也都知道==与equals的区别：  &lt;br /&gt;
==表示的是变量值完成相同（对于基础类型，地址中存储的是值，引用类型则存储指向实际对象的地址）；  &lt;br /&gt;
equlas()方法的正确理解应该是：判断两个对象是否相等。那么判断对象相等的标尺又是什么？在object类中，此标尺即为==。当然，这个标尺不是固定的，其他类中可以按照实际的需要对此标尺含义进行重定义。如String类中则是依据字符串内容是否相等来重定义了此标尺含义。如此可以增加类的功能型和实际编码的灵活性。当然了，如果自定义的类没有重写equals()方法来重新定义此标尺，那么默认的将是其父类的equals()，直到object基类。&lt;/p&gt;

&lt;p&gt;需要注意如果equals重写了，hashCode方法也应该重写，而且当equals为真，hashCode值应该一致，这是最佳实践，也是通用协定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Aktf9sH.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;以上是节选自JDK文档中的描述。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;hashcode&quot;&gt;hashCode方法&lt;/h3&gt;
&lt;p&gt;hashCode()方法返回一个整形数值，表示该对象的哈希码值。
hashCode()具有如下约定：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在Java应用程序程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致。&lt;/li&gt;
  &lt;li&gt;如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等。&lt;/li&gt;
  &lt;li&gt;反之，两个对象调用hasCode()返回的哈希码相等，这两个对象不一定相等。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;可能有人在此产生疑问：既然比较两个对象是否相等的唯一条件（也是冲要条件）是equals，那么为什么还要弄出一个hashCode()，并且进行如此约定，弄得这么麻烦？&lt;/li&gt;
    &lt;li&gt;其实，这主要体现在hashCode()方法的作用上，其主要用于增强哈希表的性能。
以集合类中，以Set为例，当新加一个对象时，需要判断现有集合中是否已经存在与此对象相等的对象，如果没有hashCode()方法，需要将Set进行一次遍历，并逐一用equals()方法判断两个对象是否相等，此种算法时间复杂度为o(n)。通过借助于hasCode方法，先计算出即将新加入对象的哈希码，然后根据哈希算法计算出此对象的位置，直接判断此位置上是否已有对象即可。（注：Set的底层用的是Map的原理实现）&lt;/li&gt;
    &lt;li&gt;在此需要纠正一个理解上的误区：对象的hashCode()返回的不是对象所在的物理内存地址。甚至也不一定是对象的逻辑地址，hashCode()相同的两个对象，不一定相等，换言之，不相等的两个对象，hashCode()返回的哈希码可能相同。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;clone&quot;&gt;clone方法&lt;/h3&gt;
&lt;p&gt;clone方法虽然使用的不多，但是如果需要重复创建多个相同对象的时候，可以使用这个方法，使用方法也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return super.clone();//这里返回的是一个Object类型的，需要依据实际情况进行转型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用clone方法，需要注意的一点是：clone的对象，如果有有引用类型的属性，是需要深度克隆的，否则，clone的对象和原对象是的属性引用指向的是相同的实例。&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Sep 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/java/2016/09/06/java-equals-hashcode.html</link>
        <guid isPermaLink="true">http://colorful.ren/java/2016/09/06/java-equals-hashcode.html</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>java集合备忘录</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;java集合的总体框架&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;java集合的运用和认识的深入程度是一个java程序员水平的重要体现，但是要想把这一部分的内容理解透彻，深刻掌握是需要整理和总结的。以前总结过，但是没有形成文字，时间长了难免会忘记，现在记录在此。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;java&quot;&gt;java集合的总体框架&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/j6gYadi.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;java集合类框架有两个顶层接口,有多个子接口和抽象类，若干实现类。这些接口和类可以抽象的分成2类：一类是”序列”,一类是”键值对”。其实就是下面这两类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java.util.Collection
java.util.Map
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们不讨论抽象类，直接说实现类。  &lt;br /&gt;
Collection的具体实现分成两部分：List相关的和Set相关的。List和Set都是接口。两者最大的区别就是元素是否唯一。List是不唯一的，Set是唯一的。  &lt;br /&gt;
List的具体实现有下面几种:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayList
LinkedList
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;ArrayList是一个数组队列，相当于动态数组。它是由数组实现的，随机访问效率高，随机插入，删除效率低&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;LinkedList是一个双向链表。它可以被当做堆栈，队列或者双向队列进行操作。随机访问效率低，但是插入、删除效率高&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;ArryList和LinkedList都不是线程安全的，想要线程安全，可以使用Collections.synchronizedList(List list)进行处理&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;List当然还有其他的实现类，比如：Vector，Stack。这些因为比较&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 24 Aug 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/java/2016/08/24/javacollection.html</link>
        <guid isPermaLink="true">http://colorful.ren/java/2016/08/24/javacollection.html</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>SSH的点点滴滴</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;以前看电影，黑客们在一个黑乎乎的界面的噼里啪啦一顿狂敲，往往能解决一个严重的问题，那个黑乎乎的界面上看上去是那么高端。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;ssh&quot;&gt;什么是SSH&lt;/h4&gt;

&lt;h4 id=&quot;ssh-1&quot;&gt;常用的SSH工具有哪些怎样选择&lt;/h4&gt;

</description>
        <pubDate>Wed, 10 Aug 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/linux/2016/08/10/ssh.html</link>
        <guid isPermaLink="true">http://colorful.ren/linux/2016/08/10/ssh.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>成熟</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;什么是成熟&lt;/h3&gt;

&lt;blockquote&gt;

  &lt;p&gt;一种明亮而不刺眼的光辉&lt;br /&gt;
一种圆润而不腻耳的音响&lt;br /&gt;
一种不需要对别人察言观色的从容&lt;br /&gt;
一种终于停止向周围申诉求告的大气&lt;br /&gt;
一种不理会哄闹的微笑&lt;br /&gt;
一种洗刷了偏激的淡漠&lt;br /&gt;
一种无须伸张的厚实&lt;br /&gt;
一种并不陡峭的高度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是我在公司的一次培训的教材上看到的文字，后来经过多方查找发现这段文字出自著名作家&lt;em&gt;余秋雨&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;当时看到这段话，有一种豁然开朗，恍然大悟的感觉。是啊，真正的成熟就是作者描述的这样：平和，温润，但又充满力量。&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Feb 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/fulin/2016/02/25/grow.html</link>
        <guid isPermaLink="true">http://colorful.ren/fulin/2016/02/25/grow.html</guid>
        
        
        <category>fulin</category>
        
      </item>
    
  </channel>
</rss>
