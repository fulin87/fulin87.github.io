<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2B程序员的笔记</title>
    <description></description>
    <link>http://colorful.ren/</link>
    <atom:link href="http://colorful.ren/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 12 Oct 2016 11:29:54 +0800</pubDate>
    <lastBuildDate>Wed, 12 Oct 2016 11:29:54 +0800</lastBuildDate>
    <generator>Jekyll v3.0.0</generator>
    
      <item>
        <title>FastJson的使用与源码解读</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/alibaba/fastjson/wiki&quot;&gt;FastJSON&lt;/a&gt;&lt;/strong&gt;是一个处理&lt;strong&gt;&lt;a href=&quot;http://json.org&quot;&gt;JSON&lt;/a&gt;&lt;/strong&gt;的 java 工具包， json （反序列化）和对象转 json （序列化）两部分的功能。是由阿里使用Apache License 2.0协议开源，易用，无依赖，性能优越，唯一不足的是文档不完善，用户需要自己根据源码来摸索。这里记录一下自己的学习历程，作为我膜拜大师杰作，虚心偷技的成果，也方便来者学习。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;主要功能&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;FastJson的最主要的使用入口是 com.alibaba.fastjson.JSON 的一系列静态方法&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; // 把JSON文本parse为JSONObject或者JSONArray 
 public static final Object parse(String text); 
 // 把JSON文本parse成JSONObject
 public static final JSONObject parseObject(String text)； 
 // 把JSON文本parse为JavaBean
 public static final  T parseObject(String text, Class clazz); 
 // 把JSON文本parse成JSONArray
 public static final JSONArray parseArray(String text); 
 // 把JSON文本parse成JavaBean集合
 public static final  List parseArray(String text, Class clazz); 
 // 将JavaBean序列化为JSON文本
 public static final String toJSONString(Object object); 
 // 将JavaBean序列化为带格式的JSON文本 
 public static final String toJSONString(Object object, boolean prettyFormat); 
 // 将JavaBean转换为JSONObject或者JSONArray。
 public static final Object toJSON(Object javaObject); 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FastJson 的相关类的说明&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; SerializeWriter：	相当于StringBuffer
 JSONArray：			相当于List&amp;lt;Object&amp;gt;
 JSONObject：			相当于Map&amp;lt;String, Object&amp;gt;
 JSON反序列化没有真正的数组，本质类型都是List&amp;lt;Object&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FastJson 的高级特性&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 支持注解、支持全类型序列化，这些都是很好的特性，功能强大
 比如有一个注解：@JSONField;就可以实现序列号和反序列化的时候bean的属性名的灵活配置，非常实用。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;源码解析&lt;/h3&gt;

 	&lt;img src=&quot;/image/fastJson.PNG&quot; alt=&quot;test&quot; /&gt;

&lt;p&gt;已经有前辈总结了一套 &lt;strong&gt;&lt;a href=&quot;http://www.csdn.net/article/2014-09-25/2821866&quot;&gt;FastJson的源码研究&lt;/a&gt;&lt;/strong&gt; 心得,可以先理解透彻再自己去看源代码。
 记录在此，以后来完善。&lt;/p&gt;

</description>
        <pubDate>Mon, 10 Oct 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/java/2016/10/10/fastjson.html</link>
        <guid isPermaLink="true">http://colorful.ren/java/2016/10/10/fastjson.html</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>忒修斯之船 &amp; 数据库</title>
        <description>&lt;p&gt;&lt;code&gt;这是一个古老的哲学问题&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;忒修斯的船在海上航行了几百年,它被不间断地维修和替换部件。只要一块木板腐烂了，它就会被替换掉，以此类推，直到所有的功能部件都不是最开始的那些了。
问题是，最终产生的这艘船是否还是原来的那艘特修斯之船，还是一艘完全不同的船？如果不是原来的船，那么在什么时候它不再是原来的船了？
哲学家托马斯·霍布斯后来对此进来了延伸，如果用特修斯之船上取下来的老部件来重新建造一艘新的船，那么两艘船中哪艘才是真正的特修斯之船？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;几百年来，人们在这个问题上争论不休，谁也不能彻底说服对方，但是这个看似不能解决的问题却能带给我们一定的启发，那就是可以解释生活中的现象&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一群能力超群的软件工程师在一家软件公司工作，做了一个伟大的产品，经过几年的迭代，产品从UI到逻辑，甚至数据库结构都发生了翻天覆地的变化，以至于这个产品最初的创造者也看不懂它的源代码了，越来越多的人开始吐槽……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;问题来了，这个产品还是原来的那个伟大的产品吗？&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;渐变&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;数据库中有一条SKU的数据记录，本来SKU编码可以用来识别这条数据的唯一性。
可惜，一开始的时候为了图方便没有定好编码生成规则，后来需要改。
这一改麻烦了，唯一性只好由SKU的ID来负责，这也带来了一连串的问题因为
SKU的编码原本不仅有唯一性的约束功能，还有很多识别功能，而ID显然是没有。
因为变更，也带来的新的问题：怎样监控变更的历史。
于是诸如这样新的字段被不断加入

&quot;update_time ; insert_time ; update_user ; last_status&quot;

这些新增的信息让我们能尽可能多的追溯到当时的场景，可是这样好吗？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;悲哀的是，现实中大部分的软件系统，都无法逃脱冗余和混乱的宿命，这也再次印证了物理中“熵”的概念：任何事物都是朝混乱度大的方向发展。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;质变&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;如果不是原来的船，那么在什么时候它不再是原来的船了?&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当唯一识别标示失效的时候，它就不再是原来的船了。可是，什么是唯一识别标示？
身份证可以伪装，DNA都有可能相同，茫茫人海，是有可能存在两个你无法区分的人的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;世界上不存在绝对的唯一性，所谓的唯一只存在于我们的想象中&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;启示&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;“任何系统熵都是逐渐变大的，自然状态下无法逆转，若想改变，必须做功。”
这一物理学的规律同样适用于现实生活。虽然我们无法做的绝对，但是可以尽量精确。
流程和标准就是行之有效的方法，甚至是唯一可行的方法。
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 10 Oct 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/life/2016/10/10/tui-xiu-shi-db.html</link>
        <guid isPermaLink="true">http://colorful.ren/life/2016/10/10/tui-xiu-shi-db.html</guid>
        
        
        <category>life</category>
        
      </item>
    
      <item>
        <title>杨德昌的那些经典电影</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在今年的十一国庆，老婆带着孩子回老家了，我一个人在家，这是少有的属于自己的时间，从一个安静的上午一直持续到晚上，我默默的看完了杨德昌的《一 一》;《枯岭街少年杀人事件》;《恐怖分子》这三部电影，这是迄今为止，我看过的最好看的几部华语电影，没有之一，看完之后，我感觉我的世界观都变了……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;慢的力量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;看似缓慢舒缓的叙事背后，却隐藏着巨大的力量，这是看这几部电影最大的感受。
让我从此喜欢上了一切&quot;慢&quot;的事物，突然发现周围的一切都协调了。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;改变了又能怎么样&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;这是《一 一》里面的一句台词，“多年之后，和当年的初恋再次相遇，虽然都依然爱着对方，又能怎么样？
我现在至少还有家人。” 这场景本身慢慢体会，就已经很有意思了。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;真正的恐怖分子就在日常生活之中&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;《恐怖分子》中，男主人公长期受到生活的压抑，面对老婆的离去和朋友的小看，依然隐忍。
在工作中他心胸狭窄，为了升迁不惜出卖朋友，为了生活他很少和朋友联系。
在得知自己没有升迁，老婆背叛之后，梦到自己的复仇，可惜这一切都是幻想，最终只能自我了断。
看完这部电影，让人有一种说不出的苍凉感和无力感还有恐惧感，男主人为何会有这个结局。
我想导演已经通过台词说了：&quot;我很少看书，也不看小说&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;看杨导的电影，需要极大的耐心，他的电影都很长，有的一部就有4个小时。白水煮豆腐似得叙事风格，温暖的音乐元素，鲜明的时代感和深刻的哲思，让人身临其境，看完意犹未尽发人深省，我想这可能就是大师吧。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 08 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/life/2016/10/08/move-yangdecang.html</link>
        <guid isPermaLink="true">http://colorful.ren/life/2016/10/08/move-yangdecang.html</guid>
        
        
        <category>life</category>
        
      </item>
    
      <item>
        <title>mysql中sql优化的常识总结</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;mysql的性能优化牵扯的范围很广，大致可以分为：
索引优化，查询优化，查询缓存，服务器设置优化，操作系统和硬件优化，应用层面优化（web服务器，缓存）等等。这里仅仅总结一下编写sql语句时应该注意的细节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;sql&quot;&gt;编写高质量的sql语句的基本原则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;尽量避免全表扫描&lt;/li&gt;
  &lt;li&gt;查询尽量使用索引&lt;/li&gt;
  &lt;li&gt;尽量避免排序&lt;/li&gt;
  &lt;li&gt;DML语句尽量在一个数据库事务中完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;具体的优化技巧如下&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1,禁止使用　select * from table ;尽量查询特定的字段.
  select * 会增加数据库开销

2,尽量不使用游标.
  游标比常规的sql语句需要更大的开销

3,尽量不要在索引字段上进行运算.
  在索引字段上进行运算会使索引失效

4,避免使用!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符.
  这会使系统无法使用索引,而只能直接搜索表中的数据，有些还是全表扫描

5,尽量使用数字型字段.
  如果字段是字符串类型，数据库引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了

6,合理使用EXISTS,NOT EXISTS子句
  如果需要判断记录是否存在，直接合理使用EXISTS,NOT EXISTS子句比count的效率要高，也比in的性能要高

7,能够用BETWEEN的就不要用IN

8,能够用DISTINCT的就不用GROUP BY

9,尽量不要用SELECT INTO语句。SELECT INTO 语句会导致表锁定，阻止其他用户访问该表

10,必要时强制查询优化器使用某个索引

11,能用UNION ALL就不要用UNION
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;这些可以说是sql语句优化的基本常识了，必须会使用，熟练使用。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 27 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/mysql/2016/09/27/mysql-right.html</link>
        <guid isPermaLink="true">http://colorful.ren/mysql/2016/09/27/mysql-right.html</guid>
        
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>mysql的数据备份和恢复</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#mysql&quot; id=&quot;markdown-toc-mysql&quot;&gt;mysql的二进制日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据库的备份和恢复是每个DBA必须掌握的技能。作为开发人员来说，适当的了解，也是有必要的。曾经我就遇到过一个面试官问过我：是否会进行数据库备份和恢复，什么是热备份，什么是冷备份。当然，我不能说这是DBA的工作，只能怪自己学的不够广。当学会了数据库的备份和恢复，再次使用数据库的时候，视野就更开阔了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;mysql&quot;&gt;mysql的二进制日志&lt;/h3&gt;

&lt;p&gt;说起mysql的备份和恢复，就必须说mysql的二进制日志，它记录的是所有mysql数据库发生变更的信息，因此对数据库非常重要&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;主要作用有以下几个方面&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;可以用于数据库基于时间点的还原&lt;/li&gt;
      &lt;li&gt;可以用来分析数据库发生变更的情况，比如程序程序bug导致数据库数据更改等。&lt;/li&gt;
      &lt;li&gt;二进制日志还可以用来重建数据库&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二进制日志功能配置&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;开启bin_log日志功能,在my.cnf中修改，在[mysqld]下增加:&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; log-bin=/tmp/mysql-log
 binlog_format=mixed
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看二进制日志功能是否开启&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; show variables like &#39;%log_bin%&#39;;
 +---------------------------------+----------------------+
 | Variable_name                   | Value                |
 +---------------------------------+----------------------+
 | log_bin                         | ON                   |
 | log_bin_basename                | /tmp/mysql-log       |
 | log_bin_index                   | /tmp/mysql-log.index |
 | log_bin_trust_function_creators | OFF                  |
 | log_bin_use_v1_row_events       | OFF                  |
 | sql_log_bin                     | ON                   |
 +---------------------------------+----------------------+
 6 rows in set
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看二进制文件的情况&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; show master logs;
 +------------------+-----------+
 | Log_name         | File_size |
 +------------------+-----------+
 | mysql-log.000001 |       143 |
 | mysql-log.000002 |       562 |
 +------------------+-----------+
 2 rows in set
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;或者&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; show binary logs;
 +------------------+-----------+
 | Log_name         | File_size |
 +------------------+-----------+
 | mysql-log.000001 |       143 |
 | mysql-log.000002 |       562 |
 +------------------+-----------+
 2 rows in set
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换二进制文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; flush logs;
 Query OK, 0 rows affected

 mysql&amp;gt; show binary logs;
 +------------------+-----------+
 | Log_name         | File_size |
 +------------------+-----------+
 | mysql-log.000001 |       143 |
 | mysql-log.000002 |       609 |
 | mysql-log.000003 |       120 |
 +------------------+-----------+
 3 rows in set
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除或者初始化二进制文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; reset master;
 Query OK, 0 rows affected
	
 mysql&amp;gt; show binary logs;
 +------------------+-----------+
 | Log_name         | File_size |
 +------------------+-----------+
 | mysql-log.000001 |       120 |
 +------------------+-----------+
 1 row in set
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定二进制日志失效期&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; show variables like &quot;%expire%&quot;;
 +--------------------------------+-------+
 | Variable_name                  | Value |
 +--------------------------------+-------+
 | disconnect_on_expired_password | ON    |
 | expire_logs_days               | 0     |
 +--------------------------------+-------+
 2 rows in set

 mysql&amp;gt; set global  expire_logs_days=5;
 Query OK, 0 rows affected
	
 mysql&amp;gt; show variables like &quot;%expire%&quot;;
 +--------------------------------+-------+
 | Variable_name                  | Value |
 +--------------------------------+-------+
 | disconnect_on_expired_password | ON    |
 | expire_logs_days               | 5     |
 +--------------------------------+-------+
 2 rows in set
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二进制日志的格式的查看和格式介绍,这里仅做了解,有三种&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; show variables like &#39;%format%&#39;;
 +--------------------------+-------------------+
 | Variable_name            | Value             |
 +--------------------------+-------------------+
 | binlog_format            | MIXED             |
 | date_format              | %Y-%m-%d          |
 | datetime_format          | %Y-%m-%d %H:%i:%s |
 | default_week_format      | 0                 |
 | innodb_file_format       | Antelope          |
 | innodb_file_format_check | ON                |
 | innodb_file_format_max   | Antelope          |
 | time_format              | %H:%i:%s          |
 +--------------------------+-------------------+
 8 rows in set

 Row : 日志中会记录成每一行数据被修改的形式，然后在 slave 端再对相同的数据进行修改
 Statement ： 每一条会修改数据的 SQL 都会记录到 master 的 bin-log 中。slave 在复制的时候 SQL 进程会解析成和原来 master 端执行过的相同的 SQL 再次执行。
 Mixed : MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 statement 和 row 之间选择一种,相当于前两种的混合。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看二进制日志文件的内容&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; # mysqlbinlog mysql-log.00000

 SET TIMESTAMP=1474882546/*!*/;
 insert into t select * from t
 /*!*/;
 # at 739
 #160926  2:35:46 server id 1  end_log_pos 770 CRC32 0x45bf6de6 	Xid = 98
 COMMIT/*!*/;
 # at 770
 #160926  2:35:47 server id 1  end_log_pos 849 CRC32 0xdcad682e 	Query	thread_id=1	exec_time=0	error_code=0
 SET TIMESTAMP=1474882547/*!*/;
 BEGIN
 /*!*/;
 # at 849
 #160926  2:35:47 server id 1  end_log_pos 952 CRC32 0x596b7cf9 	Query	thread_id=1	exec_time=0	error_code=0
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;仔细观察会发现，这里记录了数据库的每一次查询和修改过程，就像数据库的变更记录一样，难怪可以用来恢复数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 26 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/mysql/2016/09/26/mysql-log.html</link>
        <guid isPermaLink="true">http://colorful.ren/mysql/2016/09/26/mysql-log.html</guid>
        
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>全栈还是专攻，这是一个问题</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;经常会浏览一下招聘网站，一方面，可以了解现在的市场行情，另一方面，可以了解目前行业使用的技术都有什么，具体有些什么要求，这是我根据我浏览很多信息之后的一点感悟&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;以下是我在某job上截取的一段用人单位的提出的技能要求:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、计算机相关专业本科及以上学历，3年以上Java开发工作经验；
2、熟悉MVC设计模式，熟悉Java领域常用的开源框架，如Spring、Struts、Ibatis、Hibernate等；
3、熟悉面向对象编程思想和设计模式；
4、熟悉多线程编程，熟悉socket编程、WebService接口技术；
5、熟悉MINA、Volley等网络通信应用框架，有MINA开发经验者优先。
6、熟悉Oracle、MySql等数据库，并有开发经验；
7、熟悉linux/UNIX等操作系统，了解Shell；
8、较强的表达和沟通能力，善于团队合作；
9、互联网金融开发经验者优先，有大容量、高性能、高可用、分布式、架构设计经验者优先；
10、熟悉hadoop/spark等大数据应用框架优先
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;这是大部分互联网公司开出的技能要求，有的甚至更多。那么问题来了, 业内的人都知道，任何一项技术，要想熟练掌握，是需要沉淀的，有一个广为人知的说法叫一万小时理论也就是说一项技术需要熟练掌握需要至少刻意练习10000小时，也就是3年&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;回到上面的技能要求上，上面的任何一项技能都可以单独拎出来，写成一本书，够研究好几年的，有些技术甚至够研究一辈子了，比如上面提到的：&lt;strong&gt;&lt;em&gt;大容量、高性能、高可用、分布式、hadoop/spark&lt;/em&gt;&lt;/strong&gt;，先不说其他的，单单能同时掌握这些，就已经属于稀有天才了。&lt;/p&gt;

&lt;p&gt;互联网的后端技术都是围绕两个主题展开的&lt;em&gt;大数据量&lt;/em&gt;和&lt;em&gt;高并发&lt;/em&gt;。精通其中一项基本可以在职场纵横天下了。&lt;/p&gt;

&lt;p&gt;既然如此，用人单位为什么要提出如此苛刻的要求呢？我认为原因主要有以下几个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一线城市人力成本急剧上升，尤其是以信息技术为代表的IT行业&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 一线城市的房价暴涨，想留住人才，薪资往往是最具有吸引力的，所以出现了现在大家知道的一线开发人员动辄月薪数万，因此用人单位希望招到能力强的人，一个人顶几个用，也就是说希望自己的员工是个多面手。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;技术更新换代快，系统质量和用户体验要求越来越高&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 用户对产品不断提出更高的要求，更好的用户体验。
 对这些功能最好的保证就是高水平的开发人员。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用人单位需要的是全而专的人&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 认真开用人单位的用人要求，大部分都是要求&quot;熟悉&quot;，并没有要求&quot;精通&quot;。
 因此有理由相信用人单位需要的是视野开阔，对多种技术均有涉猎，但又能精通一两种的人
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;经过以上的分析，也知道以后自己的道路该怎么走了，那就是，既要要有知识的广度，也要有专业的深度。我认为，深度比广度重要。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 26 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/fulin/2016/09/26/job.html</link>
        <guid isPermaLink="true">http://colorful.ren/fulin/2016/09/26/job.html</guid>
        
        
        <category>fulin</category>
        
      </item>
    
      <item>
        <title>mysql中使用explain来分析Sql语句的性能</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;语法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;SQL优化的基本思路就是，先找到性能差的语句，然后找到性能差的原因，然后优化。当我们找到目标SQL之后，可以使用explain来分析SQL语句的执行过程，说白了就是看看这个语句的执行计划，找到性能瓶颈。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;语法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;explain &amp;lt;语句&amp;gt;  //explain是专门分析select等查询语句的执行计划的
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;例子&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;执行以下sql语句，看一下它的执行计划(&lt;em&gt;这是一个比较复杂的查询了，比较典型&lt;/em&gt;)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; EXPLAIN 
     SELECT
         o.order_id,
         o.order_sn,
         o.parent_order_sn,
         o.outer_id,
         e.pay_work_code,
         o.add_time,
         o.order_source,
         p.product_id,
         p.product_num,
         p.product_name,
         p.sell_num,
         p.sell_price,
         t.cacle_time,
         t.order_id
     FROM
         gshop_order o
     LEFT JOIN gshop_order_product p ON o.order_id = p.order_id
     LEFT JOIN gshop_order_ext e ON o.order_id = e.order_id
     LEFT JOIN (
         SELECT
             g1.order_id,
             g1.order_sn,
             g1.parent_order_sn,
             g1.outer_id,
             g2.from_status,
             g2.add_time AS cacle_time,
             g2.to_status,
             count(*) AS nums
         FROM
             gshop_order g1
         LEFT JOIN gshop_order_log g2 ON g1.order_id = g2.order_id
         WHERE
             g1.order_belong = 3
         AND g1.order_status = 13
         AND g1.sfv_download = 0
         AND (
             g1.order_source = 22
             OR g1.order_source = 26
         )
         AND g2.from_status = 5
         AND g2.to_status = 13
         AND g2.add_time &amp;gt; 1472610864
         GROUP BY
             g1.order_id
     ) t ON o.order_id = t.order_id
     WHERE
         t.order_id IS NOT NULL
     ORDER BY
         t.cacle_time DESC
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行结果如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; +----+-------------+------------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+---------+----------------------+------+-----------------------------+
 | id | select_type | table      | type   | possible_keys                                                                                                                                                 | key         | key_len | ref                  | rows | Extra                       |
 +----+-------------+------------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+---------+----------------------+------+-----------------------------+
 |  1 | PRIMARY     | &amp;lt;derived2&amp;gt; | ALL    | NULL                                                                                                                                                          | NULL        | NULL    | NULL                 |    2 | Using where; Using filesort |
 |  1 | PRIMARY     | o          | eq_ref | PRIMARY                                                                                                                                                       | PRIMARY     | 4       | t.order_id           |    1 | NULL                        |
 |  1 | PRIMARY     | p          | ref    | idx_orderid                                                                                                                                                   | idx_orderid | 4       | t.order_id           |    1 | NULL                        |
 |  1 | PRIMARY     | e          | eq_ref | order_id                                                                                                                                                      | order_id    | 4       | t.order_id           |    1 | NULL                        |
 |  2 | DERIVED     | g1         | ref    | PRIMARY,idx_userid,idx_ordersn,idx_addtime_status,idx_areanumber,idx_couponid,idx_parentorderid,idx_parentordersn,idx_paytime_payid,idx_shippingsn,idx_status | idx_status  | 1       | const                |    2 | Using where                 |
 |  2 | DERIVED     | g2         | ref    | idx_orderid                                                                                                                                                   | idx_orderid | 4       | gshop_db.g1.order_id |    1 | Using where                 |
 +----+-------------+------------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+---------+----------------------+------+-----------------------------+
 6 rows in set
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;explain 结果详解&lt;/p&gt;

    &lt;p&gt;看到	explain 出来的结果，相信初学者应该已经懵逼了，面对这种情况，千万不能慌，要沉住气，要相信 &lt;em&gt;“我们的宇宙是存在规律的，并且规律是可以被认识的”&lt;/em&gt;，其实就是说，所有的技术，只要认真学，都是可以学会的，下面对explain结果的每一个字段的含义进行解释&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; id
     SQL执行顺序的标识，执行顺序是从大到小，例子中最先执行的是id为2的，也就是说是从下往上执行的。

 select_type
     就是select的类型,有这么几种：
     SIMPLE ： 简单SELECT(不使用UNION或子查询等）
     primary ： 最外层的select，在有子查询的语句中，最外层的select就是primary
     union : union语句的第二个或者说是后面那一个
     DEPENDENT UNION : UNION中的第二个或后面的SELECT语句，取决于外面的查询
     UNION RESULT : UNION的结果
     SUBQUERY : 子查询中的第一个SELECT
     DEPENDENT SUBQUERY : 子查询中的第一个SELECT，取决于外面的查询
     DERIVED : 派生表的SELECT(FROM子句的子查询)

 table
     显示这一行的数据是关于哪张表的.有时不是真实的表名字,看到的derivedx(x是个数字,我的理解是第几步执行的结果)

 type
     这列很重要,显示了连接使用了哪种类别,有无使用索引.从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL
     system : 这是const联接类型的一个特例。表仅有一行满足条件.
     const : 表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const表很快，因为它们只读取一次！const用于用常数值比较PRIMARY KEY或UNIQUE索引的所有部分时
     eq_ref : 对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY。eq_ref可以用于使用= 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。
     ref : 对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。ref可以用于使用=或&amp;lt;=&amp;gt;操作符的带索引的列。
     ref_or_null : 该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。
     index_merge : 该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。
     unique_subquery : 该类型替换了下面形式的IN子查询的ref：
         value IN (SELECT primary_key FROM single_table WHERE some_expr)
         unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。
     index_subquery : 该联接类型类似于unique_subquery。可以替换IN子查询
     range : 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。在该类型中ref列为NULL。当使用=、&amp;lt;&amp;gt;、&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=、IS NULL、&amp;lt;=&amp;gt;、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range
     index : 该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。当查询只使用作为单索引一部分的列时，MySQL可以使用该联接类型。
     ALL ： 对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。

 possible_keys
     possible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询

 key
     key列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。

 key_len
     key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好

 ref
     ref列显示使用哪个列或常数与key一起从表中选择行。

 rows
     rows列显示MySQL认为它执行查询时必须检查的行数。

 Extra
     该列包含MySQL解决查询的详细信息，下面是详细信息
     Distinct ： 一旦MYSQL找到了与行相联合匹配的行，就不再搜索了
     Not exists ： MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行就不再搜索了
     Range checked for each Record（index map:#）： 没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一
     Using filesort www.2cto.com ： 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行
     Using index ： 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候
     Using temporary ： 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上
     Using where ： 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本例的执行计划解读&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

  	sql语句的执行是按照执行计划从下往上执行的，从执行计划可以看出，最先执行的是表连接中的查询，生成临时表与其他表连接查询，其他表都走的是索引，唯独临时表使用的是全表扫描。
</description>
        <pubDate>Fri, 23 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/mysql/2016/09/23/mysql-explain.html</link>
        <guid isPermaLink="true">http://colorful.ren/mysql/2016/09/23/mysql-explain.html</guid>
        
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>mysql中sql优化的思路和原则</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;入乎其内；出乎其外&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#sql&quot; id=&quot;markdown-toc-sql&quot;&gt;SQL优化的思路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#sql-1&quot; id=&quot;markdown-toc-sql-1&quot;&gt;SQL优化的基本原则&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;索引相关的总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;大部分系统的性能瓶颈都是IO操作，数据库的IO消耗是其中的重要组成部分，SQL语句性能的优化是很有必要的，如果一开始不注意，后期的改动成本是比较大的,下面是根据我自己的经验总结的一套sql优化的思路和方法，不一定是最好的，但是却真实的产生过效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;入乎其内；出乎其外&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;为什么人类到今天为止对宇宙的认识都很有限？因为我们自己就在宇宙之中；为什么人类到今天为止对海洋的认识都很少？因为人类从来没有正真的进入过海洋！&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;一样的道理，认识一个事物，最有效的方式就是：先站在事物的外面观察观察它，然后进入事物的内部再研究它，这样才是最全面的。&lt;/p&gt;

&lt;p&gt;对于SQL来说，平时使用sql，编写sql语句就相当于站在sql的外面观察它，但是sql的内部机制和执行过程是怎样的呢？一个sql语句的执行过程，大致是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;8	SELECT  DISTINCT &amp;lt;select_list&amp;gt;
1	FROM &amp;lt;left_table&amp;gt;
3	&amp;lt;join_type&amp;gt;JOIN&amp;lt;right_table&amp;gt;
2		ON&amp;lt;join_condition&amp;gt;
4	WHERE &amp;lt;where_condition&amp;gt;
5	GROUP BY&amp;lt;group_by_list&amp;gt;
6	WITH{CUBE|ROLLUP}
7	HAVING&amp;lt;having_condition&amp;gt;
10	ORDER BY&amp;lt;order_by_list&amp;gt;
11	LIMIT&amp;lt;limit_number&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是详细的执行过程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1,FROM : 	对FROM的左边表和右边的表计算笛卡尔积，产生虚拟表VT1。
2,ON : 		对虚拟表VT1进行ON筛选，只有那些符合&amp;lt;join_condition&amp;gt;的行才会被记录在虚拟表VT2中。
3,JOIN : 	如果指定了OUTER JOIN (比如left join,right join),那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3,from 字句中包含两个以上的表的话，就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1-3这三个步骤，一直到处理完所有的表为止。
4,WHERE : 	对虚拟表VT3进行WHERE条件过滤。只要符合&amp;lt;where-condition&amp;gt;的记录才会被插入到虚拟表VT4中。
5,GROUP BY : 	根据group by字句中的列，对VT4中的记录进行分组操作，产生VT5。
6,CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6。
7,HAVING：	对虚拟表VT6应用having过滤，只有符合&amp;lt;having-condition&amp;gt;的记录才会被 插入到虚拟表VT7中。
8,SELECT： 	执行select操作，选择指定的列，插入到虚拟表VT8中。
9,DISTINCT： 	对VT8中的记录进行去重。产生虚拟表VT9。
10,ORDER BY: 	将虚拟表VT9中的记录按照&amp;lt;order_by_list&amp;gt;进行排序操作，产生虚拟表VT10。
11,LIMIT：	取出指定行的记录，产生虚拟表VT11, 并将结果返回。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sql&quot;&gt;SQL优化的思路&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1.优化更需要优化的sql；&lt;/li&gt;
  &lt;li&gt;2.定位优化对象的性能瓶颈：优化前需了解查询的瓶颈是IO还是CPU可通过PROFILING很容易定位查询的瓶颈。&lt;/li&gt;
  &lt;li&gt;3.明确优化目标；&lt;/li&gt;
  &lt;li&gt;4.从Explain入手；&lt;/li&gt;
  &lt;li&gt;5.多使用profile；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-1&quot;&gt;SQL优化的基本原则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;永远用小结果集驱动大结果集&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;From子句中sql解析顺序为从右向左，执行时会以最左边的表为基础表循环与右边表数据做笛卡尔积，所以以小结果集驱动能减少循环次数，从而减少对被驱动结果集的访问，从而减少被驱动表的锁定。&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;尽可能在索引中完成排序&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;排序算法有两种：a.查出排序字段和行指针，排序，再通过行指针获得行数据所需列，返回结果集；b.取出所有排序列数据，在排序缓冲区中排完序直接返回结果集。索引排序是利用索引的有序性对数据排序的。&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;只取出子集需要的colums&lt;/li&gt;
  &lt;li&gt;仅仅使用最有效的过滤条件&lt;/li&gt;
  &lt;li&gt;尽可能避免复杂的Join和子查询&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;索引相关的总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;什么是索引，可以把索引想象成数据库的目录，查找某一样东西之前，先在目录中确定好位置，直奔位置而去，这就是提高查询效率的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;索引的好处&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 提高数据检索效率，降低数据库的IO成本
 降低数据排序成本：要求排序字段和索引键字段一致
 降低数据分组成本：因为分组之前会先排序，同意如果分组字段与索引字段一致，会降低分组消耗的成本。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;索引的弊端&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 索引是独立于基础数据的数据库对象，因此它会占用存储空间
 数据新增、更新会导致索引的同步更新，所以会增加数据新增、更新所消耗的成本
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;否需要创建索引&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 较为频繁的作为查询条件的字段需要创建索引
 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
 更新非常频繁的字段不适合创建索引
 不会出现在where子句中的字段不要创建索引
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;索引语法&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;唯一索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD UNIQUE indexName (column);
  CREATE UNIQUE INDEX indexName ON tableName (column);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;普通索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD INDEX indexName(column);
  CREATE INDEX indexName ON tableName(column);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;主键索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD PRIMARY KEY (column);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;全文索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD FULLTEXT (column);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;组合索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD INDEX indexName(col1,col2,...);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 22 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/mysql/2016/09/22/mysql-update.html</link>
        <guid isPermaLink="true">http://colorful.ren/mysql/2016/09/22/mysql-update.html</guid>
        
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>mysql 基础知识</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#mysql&quot; id=&quot;markdown-toc-mysql&quot;&gt;mysql的安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mysql-1&quot; id=&quot;markdown-toc-mysql-1&quot;&gt;mysql基础信息（[]表示可选）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;大道至简，世间的道理都是相似的……   &lt;br /&gt;
  就比如学东西吧，以前总是东学一点，西学一点。到头来发现什么都会，什么都不精，所以，到头来才明白：少才是多，less is more。数据库，以后就选择mysql了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;mysql&quot;&gt;mysql的安装&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;因为仅做学习使用，这里只讲centos下的 mysql 安装过程，其他环境下的不做过多解释。而且，这里介绍的也是最方便的安装过程，不一定是最好的方式&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;操作系统信息&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Description:		CentOS Linux release 7.2.1511 (Core) 
 Release:		7.2.1511
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首先查看本系统有没有安装 mariadb&lt;/p&gt;

   	$ rpm -qa |　grep -i mariadb    //这里的-i是忽略大小写

    &lt;pre&gt;&lt;code&gt;   mariadb-libs-5.5.44-2.el7.centos.x86_64
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果有安装，则需要卸载(–nodeps意思是如果有依赖关系，则同时卸载掉)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ rpm -e --nodeps mariadb-libs-5.5.44-2.el7.centos.x86_64 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下载mysql的安装包&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ wget http://dev.mysql.com/Downloads/MySQL-5.6/MySQL-server-5.6.21-1.rhel5.x86_64.rpm
 $ wget http://dev.mysql.com/Downloads/MySQL-5.6/MySQL-devel-5.6.21-1.rhel5.x86_64.rpm
 $ wget http://dev.mysql.com/Downloads/MySQL-5.6/MySQL-client-5.6.21-1.rhel5.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装rpm软件包&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ rpm -ivh MySQL-****.rpm 	
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装MySQL-server会报一个错，因为缺少依赖，使用yum安装即可&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ yum install -y libaio
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初始化MySQL及设置密码&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ /usr/bin/mysql_install_db
 $ service mysql start
 $ cat /root/.mysql_secret  #查看root账号密码
 $ mysql -uroot -pAsTsb42   #AsTsb42是看到的密码
 mysql&amp;gt; SET PASSWORD = PASSWORD(&#39;123456&#39;);    #设置密码为123456
 mysql&amp;gt; exit
 $ mysql -uroot -p123456
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;远程登陆用户设置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; use mysql;
 mysql&amp;gt; select host,user,password from user;
 mysql&amp;gt; update user set password=password(&#39;123456&#39;) where user=&#39;root&#39;;
 mysql&amp;gt; update user set host=&#39;%&#39; where user=&#39;root&#39; and host=&#39;localhost&#39;;
 mysql&amp;gt; flush privileges;
 mysql&amp;gt; exit
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改mysql的配置文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ vi /etc/my.cnf.d/my-default.cnf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;加入如下内容：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [client]
 password=123456
 port=3306
 default-character-set=utf8
	
 [mysqld]
 port=3306
 character_set_server=utf8
 character_set_client=utf8
 collation_server=utf8_general_ci
 collation_database=utf8_general_ci
 lower_case_table_names=1
 max_connections=1000
	
 [mysql]
 default-character-set=utf8
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql的默认安装位置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; /var/lib/mysql/               #数据库目录
 /usr/share/mysql              #配置文件目录
 /usr/bin                      #相关命令目录
 /etc/init.d/mysql             #启动脚本
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql的启动和停止&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ service mysql stop
 $ service mysql start
 $ service mysql restart
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置开机自启动&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ chkconfig mysql on
 $ chkconfig --list | grep mysql
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mysql-1&quot;&gt;mysql基础信息（[]表示可选）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DBA和运维同学常用&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; -- 查看mysql版本信息
 select version(); 
		
 -- 查看字符集
 show variables like &#39;%collation%&#39;;
 show variables like &#39;%char%&#39;;	
	
 -- 查看是否打开二进制日志文件的功能	
 show variables like &#39;%log_bin%&#39;;

 -- 查看有哪些数据库	
 show databases;	

 -- 查看数据库中有哪些表			
 show tables from db_name;		

 -- 查看表的字段信息
 show COLUMNS from db_name.table_name

 -- 查看表的信息	
 show table status from db_name;		
	
 -- 查看MySQL本次启动后的运行时间(单位：秒)
 show status like &#39;uptime&#39;;
	
 -- 查看select语句的执行数
 show [global] status like &#39;com_select&#39;;
	
 -- 查看insert语句的执行数
 show [global] status like &#39;com_insert&#39;;
	
 -- 查看update语句的执行数
 show [global] status like &#39;com_update&#39;;
	
 -- 查看delete语句的执行数
 show [global] status like &#39;com_delete&#39;;
	
 -- 查看试图连接到MySQL(不管是否连接成功)的连接数
 show status like &#39;connections&#39;;
	
 -- 查看线程缓存内的线程的数量。
 show status like &#39;threads_cached&#39;;
	
 -- 查看当前打开的连接的数量。
 show status like &#39;threads_connected&#39;;
	
 -- 查看当前打开的连接的数量。
 show status like &#39;threads_connected&#39;;
	
 -- 查看创建用来处理连接的线程数。
 -- 如果Threads_created较大，你可能要增加thread_cache_size值。
 show status like &#39;threads_created&#39;;
	
 -- 查看激活的(非睡眠状态)线程数。
 show status like &#39;threads_running&#39;;
	
 -- 查看立即获得的表的锁的次数。
 show status like &#39;table_locks_immediate&#39;;
	
 -- 查看不能立即获得的表的锁的次数。
 -- 如果该值较高，并且有性能问题，你应首先优化查询，然后拆分表或使用复制。
 show status like &#39;table_locks_waited&#39;;
	
 --查看创建时间超过slow_launch_time秒的线程数。
 show status like &#39;slow_launch_threads&#39;;
	
 --查看查询时间超过long_query_time秒的查询的个数。
 show status like &#39;slow_queries&#39;;
	
 -- 查看慢查询日志功能是否开启
 show variables like &#39;%slow%&#39;;

 -- 多长时间才是慢查询
 show variables like &#39;%long%&#39;;

 -- 设置查询超过1秒就是慢查询
 set session long_query_time=1;

 -- 查看日志信息是输出到数据库还是系统文件(FILE为系统文件)
 show variables like &#39;log_output&#39;;

 -- 查看发生了多少次慢查询
 show global status like &#39;Slow_queries&#39;;

 -- 将所有没有使用到索引的sql语句都记录到慢查询日志中
 set global log_queries_not_using_indexes = true;

 -- 查看数据库文件的路径
 show variables like &quot;%datadir%&quot;;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速建立一张一模一样的表，并插入数据&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; create table t as select * from information_schema.tables；
 mysql&amp;gt; insert into t select *  from t;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 21 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/mysql/2016/09/21/mysql.html</link>
        <guid isPermaLink="true">http://colorful.ren/mysql/2016/09/21/mysql.html</guid>
        
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>plantUML的使用</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#graphviz&quot; id=&quot;markdown-toc-graphviz&quot;&gt;Graphviz的使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;经常需要画一些图，比如类图，时序图，用例图等，最近接触到一款有趣的工具，是eclipse的一个插件:plantUML。这里只记录最基础的地方，以后再来完善&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;安装&lt;/h3&gt;
&lt;p&gt;直接访问 &lt;strong&gt;&lt;a href=&quot;http://plantuml.com/&quot;&gt;plantUML官网&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;问题&lt;/h3&gt;
&lt;p&gt;安装好插件之后，此时只能使用plantUML画一些时序图，并不能从类文件直接生成类图，这时候还需要安装和配置一个十分牛*的画图工具： &lt;strong&gt;&lt;a href=&quot;http://www.graphviz.org/&quot;&gt;Graphviz&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;graphviz&quot;&gt;Graphviz的使用&lt;/h3&gt;
&lt;p&gt;仅仅使用Graphviz就已经可以画图了，直接使用Graphedit.exe程序就可以画图了，具体参照官网。&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Sep 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/java/2016/09/20/plantuml.html</link>
        <guid isPermaLink="true">http://colorful.ren/java/2016/09/20/plantuml.html</guid>
        
        
        <category>java</category>
        
      </item>
    
  </channel>
</rss>
