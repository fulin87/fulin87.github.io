<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>水货程序员的笔记</title>
    <description></description>
    <link>http://colorful.ren/</link>
    <atom:link href="http://colorful.ren/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 30 Dec 2016 18:14:10 +0800</pubDate>
    <lastBuildDate>Fri, 30 Dec 2016 18:14:10 +0800</lastBuildDate>
    <generator>Jekyll v3.0.0</generator>
    
      <item>
        <title>Python Web Server Gateway Interface v1.0 翻译</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;python官方对wsgi规范进行了描述，但是是英文的，我想尝试对其进行一下翻译。
我知道这对英文不好的我来说是一个巨大的挑战，但是我想考验一下自己…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;PEP:		333     
Title: 		Python Web Server Gateway Interface v1.0     
Author:		phillip J. Eby &amp;lt;pje@telecommunity.com&amp;gt;         
Discussions-To: Python Web-SIG &amp;lt;web-sig@python.org&amp;gt;      
Status:		Final     
Type:		Informational     
Content-Type:	text/x-rst     
Created:	07-Dec-2003     
Post-History:	07-Dec-2003, 08-Aug-2004, 20-Aug-2004, 27-Aug-2004, 27-Sep-2010     
Superseded-By:	3333     
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;preface&quot;&gt;Preface&lt;/h1&gt;

&lt;p&gt;Note: For an updated version of this spec that supports Python 3.x and
includes community errata, addenda, and clarifications, please
see PEP 3333 instead.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;

&lt;p&gt;This document specifies a proposed standard interface between web
servers and Python web applications or frameworks, to promote web
application portability across a variety of web servers.&lt;/p&gt;

&lt;h1 id=&quot;rationale-and-goals&quot;&gt;Rationale and Goals&lt;/h1&gt;

&lt;p&gt;Python currently boasts a wide variety of web application frameworks,
such as Zope, Quixote, Webware, SkunkWeb, PSO, and Twisted Web – to
name just a few [1]_.  This wide variety of choices can be a problem
for new Python users, because generally speaking, their choice of web
framework will limit their choice of usable web servers, and vice
versa.&lt;/p&gt;

&lt;p&gt;By contrast, although Java has just as many web application frameworks
available, Java’s “servlet” API makes it possible for applications
written with any Java web application framework to run in any web
server that supports the servlet API.&lt;/p&gt;

&lt;p&gt;The availability and widespread use of such an API in web servers for
Python – whether those servers are written in Python (e.g. Medusa),
embed Python (e.g. mod_python), or invoke Python via a gateway
protocol (e.g. CGI, FastCGI, etc.) – would separate choice of
framework from choice of web server, freeing users to choose a pairing
that suits them, while freeing framework and server developers to
focus on their preferred area of specialization.&lt;/p&gt;

&lt;p&gt;This PEP, therefore, proposes a simple and universal interface between
web servers and web applications or frameworks: the Python Web Server
Gateway Interface (WSGI).&lt;/p&gt;

&lt;p&gt;But the mere existence of a WSGI spec does nothing to address the
existing state of servers and frameworks for Python web applications.
Server and framework authors and maintainers must actually implement
WSGI for there to be any effect.&lt;/p&gt;

&lt;p&gt;However, since no existing servers or frameworks support WSGI, there
is little immediate reward for an author who implements WSGI support.
Thus, WSGI &lt;strong&gt;must&lt;/strong&gt; be easy to implement, so that an author’s initial
investment in the interface can be reasonably low.&lt;/p&gt;

&lt;p&gt;Thus, simplicity of implementation on &lt;em&gt;both&lt;/em&gt; the server and framework
sides of the interface is absolutely critical to the utility of the
WSGI interface, and is therefore the principal criterion for any
design decisions.&lt;/p&gt;

&lt;p&gt;Note, however, that simplicity of implementation for a framework
author is not the same thing as ease of use for a web application
author.  WSGI presents an absolutely “no frills” interface to the
framework author, because bells and whistles like response objects and
cookie handling would just get in the way of existing frameworks’
handling of these issues.  Again, the goal of WSGI is to facilitate
easy interconnection of existing servers and applications or
frameworks, not to create a new web framework.&lt;/p&gt;

&lt;p&gt;Note also that this goal precludes WSGI from requiring anything that
is not already available in deployed versions of Python.  Therefore,
new standard library modules are not proposed or required by this
specification, and nothing in WSGI requires a Python version greater
than 2.2.2.  (It would be a good idea, however, for future versions
of Python to include support for this interface in web servers
provided by the standard library.)&lt;/p&gt;

&lt;p&gt;In addition to ease of implementation for existing and future
frameworks and servers, it should also be easy to create request
preprocessors, response postprocessors, and other WSGI-based
“middleware” components that look like an application to their
containing server, while acting as a server for their contained
applications.&lt;/p&gt;

&lt;p&gt;If middleware can be both simple and robust, and WSGI is widely
available in servers and frameworks, it allows for the possibility
of an entirely new kind of Python web application framework: one
consisting of loosely-coupled WSGI middleware components.  Indeed,
existing framework authors may even choose to refactor their
frameworks’ existing services to be provided in this way, becoming
more like libraries used with WSGI, and less like monolithic
frameworks.  This would then allow application developers to choose
“best-of-breed” components for specific functionality, rather than
having to commit to all the pros and cons of a single framework.&lt;/p&gt;

&lt;p&gt;Of course, as of this writing, that day is doubtless quite far off.
In the meantime, it is a sufficient short-term goal for WSGI to
enable the use of any framework with any server.&lt;/p&gt;

&lt;p&gt;Finally, it should be mentioned that the current version of WSGI
does not prescribe any particular mechanism for “deploying” an
application for use with a web server or server gateway.  At the
present time, this is necessarily implementation-defined by the
server or gateway.  After a sufficient number of servers and
frameworks have implemented WSGI to provide field experience with
varying deployment requirements, it may make sense to create
another PEP, describing a deployment standard for WSGI servers and
application frameworks.&lt;/p&gt;

&lt;h1 id=&quot;specification-overview&quot;&gt;Specification Overview&lt;/h1&gt;

&lt;p&gt;The WSGI interface has two sides: the “server” or “gateway” side, and
the “application” or “framework” side.  The server side invokes a
callable object that is provided by the application side.  The
specifics of how that object is provided are up to the server or
gateway.  It is assumed that some servers or gateways will require an
application’s deployer to write a short script to create an instance
of the server or gateway, and supply it with the application object.
Other servers and gateways may use configuration files or other
mechanisms to specify where an application object should be
imported from, or otherwise obtained.&lt;/p&gt;

&lt;p&gt;In addition to “pure” servers/gateways and applications/frameworks,
it is also possible to create “middleware” components that implement
both sides of this specification.  Such components act as an
application to their containing server, and as a server to a
contained application, and can be used to provide extended APIs,
content transformation, navigation, and other useful functions.&lt;/p&gt;

&lt;p&gt;Throughout this specification, we will use the term “a callable” to
mean “a function, method, class, or an instance with a &lt;code&gt;__call__&lt;/code&gt;
method”.  It is up to the server, gateway, or application implementing
the callable to choose the appropriate implementation technique for
their needs.  Conversely, a server, gateway, or application that is
invoking a callable &lt;strong&gt;must not&lt;/strong&gt; have any dependency on what kind of
callable was provided to it.  Callables are only to be called, not
introspected upon.&lt;/p&gt;

&lt;h2 id=&quot;the-applicationframework-side&quot;&gt;The Application/Framework Side&lt;/h2&gt;

&lt;p&gt;The application object is simply a callable object that accepts
two arguments.  The term “object” should not be misconstrued as
requiring an actual object instance: a function, method, class,
or instance with a &lt;code&gt;__call__&lt;/code&gt; method are all acceptable for
use as an application object.  Application objects must be able
to be invoked more than once, as virtually all servers/gateways
(other than CGI) will make such repeated requests.&lt;/p&gt;

&lt;p&gt;(Note: although we refer to it as an “application” object, this
should not be construed to mean that application developers will use
WSGI as a web programming API!  It is assumed that application
developers will continue to use existing, high-level framework
services to develop their applications.  WSGI is a tool for
framework and server developers, and is not intended to directly
support application developers.)&lt;/p&gt;

&lt;p&gt;Here are two example application objects; one is a function, and the
other is a class::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def simple_app(environ, start_response):
    &quot;&quot;&quot;Simplest possible application object&quot;&quot;&quot;
    status = &#39;200 OK&#39;
    response_headers = [(&#39;Content-type&#39;, &#39;text/plain&#39;)]
    start_response(status, response_headers)
    return [&#39;Hello world!\n&#39;]


class AppClass:
    &quot;&quot;&quot;Produce the same output, but using a class

    (Note: &#39;AppClass&#39; is the &quot;application&quot; here, so calling it
    returns an instance of &#39;AppClass&#39;, which is then the iterable
    return value of the &quot;application callable&quot; as required by
    the spec.

    If we wanted to use *instances* of &#39;AppClass&#39; as application
    objects instead, we would have to implement a &#39;__call__&#39;
    method, which would be invoked to execute the application,
    and we would need to create an instance for use by the
    server or gateway.
    &quot;&quot;&quot;

    def __init__(self, environ, start_response):
        self.environ = environ
        self.start = start_response

    def __iter__(self):
        status = &#39;200 OK&#39;
        response_headers = [(&#39;Content-type&#39;, &#39;text/plain&#39;)]
        self.start(status, response_headers)
        yield &quot;Hello world!\n&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;the-servergateway-side&quot;&gt;The Server/Gateway Side&lt;/h2&gt;

&lt;p&gt;The server or gateway invokes the application callable once for each
request it receives from an HTTP client, that is directed at the
application.  To illustrate, here is a simple CGI gateway, implemented
as a function taking an application object.  Note that this simple
example has limited error handling, because by default an uncaught
exception will be dumped to &lt;code&gt;sys.stderr&lt;/code&gt; and logged by the web
server.&lt;/p&gt;

&lt;p&gt;::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import os, sys

def run_with_cgi(application):

    environ = dict(os.environ.items())
    environ[&#39;wsgi.input&#39;]        = sys.stdin
    environ[&#39;wsgi.errors&#39;]       = sys.stderr
    environ[&#39;wsgi.version&#39;]      = (1, 0)
    environ[&#39;wsgi.multithread&#39;]  = False
    environ[&#39;wsgi.multiprocess&#39;] = True
    environ[&#39;wsgi.run_once&#39;]     = True

    if environ.get(&#39;HTTPS&#39;, &#39;off&#39;) in (&#39;on&#39;, &#39;1&#39;):
        environ[&#39;wsgi.url_scheme&#39;] = &#39;https&#39;
    else:
        environ[&#39;wsgi.url_scheme&#39;] = &#39;http&#39;

    headers_set = []
    headers_sent = []

    def write(data):
        if not headers_set:
             raise AssertionError(&quot;write() before start_response()&quot;)

        elif not headers_sent:
             # Before the first output, send the stored headers
             status, response_headers = headers_sent[:] = headers_set
             sys.stdout.write(&#39;Status: %s\r\n&#39; % status)
             for header in response_headers:
                 sys.stdout.write(&#39;%s: %s\r\n&#39; % header)
             sys.stdout.write(&#39;\r\n&#39;)

        sys.stdout.write(data)
        sys.stdout.flush()

    def start_response(status, response_headers, exc_info=None):
        if exc_info:
            try:
                if headers_sent:
                    # Re-raise original exception if headers sent
                    raise exc_info[0], exc_info[1], exc_info[2]
            finally:
                exc_info = None     # avoid dangling circular ref
        elif headers_set:
            raise AssertionError(&quot;Headers already set!&quot;)

        headers_set[:] = [status, response_headers]
        return write

    result = application(environ, start_response)
    try:
        for data in result:
            if data:    # don&#39;t send headers until body appears
                write(data)
        if not headers_sent:
            write(&#39;&#39;)   # send headers now if body was empty
    finally:
        if hasattr(result, &#39;close&#39;):
            result.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;middleware-components-that-play-both-sides&quot;&gt;Middleware: Components that Play Both Sides&lt;/h2&gt;

&lt;p&gt;Note that a single object may play the role of a server with respect
to some application(s), while also acting as an application with
respect to some server(s).  Such “middleware” components can perform
such functions as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Routing a request to different application objects based on the
target URL, after rewriting the &lt;code&gt;environ&lt;/code&gt; accordingly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Allowing multiple applications or frameworks to run side-by-side
in the same process&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Load balancing and remote processing, by forwarding requests and
responses over a network&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Perform content postprocessing, such as applying XSL stylesheets&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The presence of middleware in general is transparent to both the
“server/gateway” and the “application/framework” sides of the
interface, and should require no special support.  A user who
desires to incorporate middleware into an application simply
provides the middleware component to the server, as if it were
an application, and configures the middleware component to
invoke the application, as if the middleware component were a
server.  Of course, the “application” that the middleware wraps
may in fact be another middleware component wrapping another
application, and so on, creating what is referred to as a
“middleware stack”.&lt;/p&gt;

&lt;p&gt;For the most part, middleware must conform to the restrictions
and requirements of both the server and application sides of
WSGI.  In some cases, however, requirements for middleware
are more stringent than for a “pure” server or application,
and these points will be noted in the specification.&lt;/p&gt;

&lt;p&gt;Here is a (tongue-in-cheek) example of a middleware component that
converts &lt;code&gt;text/plain&lt;/code&gt; responses to pig Latin, using Joe Strout’s
&lt;code&gt;piglatin.py&lt;/code&gt;.  (Note: a “real” middleware component would
probably use a more robust way of checking the content type, and
should also check for a content encoding.  Also, this simple
example ignores the possibility that a word might be split across
a block boundary.)&lt;/p&gt;

&lt;p&gt;::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from piglatin import piglatin

class LatinIter:

    &quot;&quot;&quot;Transform iterated output to piglatin, if it&#39;s okay to do so

    Note that the &quot;okayness&quot; can change until the application yields
    its first non-empty string, so &#39;transform_ok&#39; has to be a mutable
    truth value.
    &quot;&quot;&quot;

    def __init__(self, result, transform_ok):
        if hasattr(result, &#39;close&#39;):
            self.close = result.close
        self._next = iter(result).next
        self.transform_ok = transform_ok

    def __iter__(self):
        return self

    def next(self):
        if self.transform_ok:
            return piglatin(self._next())
        else:
            return self._next()

class Latinator:

    # by default, don&#39;t transform output
    transform = False

    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):

        transform_ok = []

        def start_latin(status, response_headers, exc_info=None):

            # Reset ok flag, in case this is a repeat call
            del transform_ok[:]

            for name, value in response_headers:
                if name.lower() == &#39;content-type&#39; and value == &#39;text/plain&#39;:
                    transform_ok.append(True)
                    # Strip content-length if present, else it&#39;ll be wrong
                    response_headers = [(name, value)
                        for name, value in response_headers
                            if name.lower() != &#39;content-length&#39;
                    ]
                    break

            write = start_response(status, response_headers, exc_info)

            if transform_ok:
                def write_latin(data):
                    write(piglatin(data))
                return write_latin
            else:
                return write

        return LatinIter(self.application(environ, start_latin), transform_ok)


# Run foo_app under a Latinator&#39;s control, using the example CGI gateway
from foo_app import foo_app
run_with_cgi(Latinator(foo_app))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;specification-details&quot;&gt;Specification Details&lt;/h1&gt;

&lt;p&gt;The application object must accept two positional arguments.  For
the sake of illustration, we have named them &lt;code&gt;environ&lt;/code&gt; and
&lt;code&gt;start_response&lt;/code&gt;, but they are not required to have these names.
A server or gateway &lt;strong&gt;must&lt;/strong&gt; invoke the application object using
positional (not keyword) arguments.  (E.g. by calling
&lt;code&gt;result = application(environ, start_response)&lt;/code&gt; as shown above.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;environ&lt;/code&gt; parameter is a dictionary object, containing CGI-style
environment variables.  This object &lt;strong&gt;must&lt;/strong&gt; be a builtin Python
dictionary (&lt;em&gt;not&lt;/em&gt; a subclass, &lt;code&gt;UserDict&lt;/code&gt; or other dictionary
emulation), and the application is allowed to modify the dictionary
in any way it desires.  The dictionary must also include certain
WSGI-required variables (described in a later section), and may
also include server-specific extension variables, named according
to a convention that will be described below.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;start_response&lt;/code&gt; parameter is a callable accepting two
required positional arguments, and one optional argument.  For the sake
of illustration, we have named these arguments &lt;code&gt;status&lt;/code&gt;,
&lt;code&gt;response_headers&lt;/code&gt;, and &lt;code&gt;exc_info&lt;/code&gt;, but they are not required to
have these names, and the application &lt;strong&gt;must&lt;/strong&gt; invoke the
&lt;code&gt;start_response&lt;/code&gt; callable using positional arguments (e.g.
&lt;code&gt;start_response(status, response_headers)&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;status&lt;/code&gt; parameter is a status string of the form
&lt;code&gt;&quot;999 Message here&quot;&lt;/code&gt;, and &lt;code&gt;response_headers&lt;/code&gt; is a list of
&lt;code&gt;(header_name, header_value)&lt;/code&gt; tuples describing the HTTP response
header.  The optional &lt;code&gt;exc_info&lt;/code&gt; parameter is described below in the
sections on &lt;code&gt;The start_response() Callable&lt;/code&gt;_ and &lt;code&gt;Error Handling&lt;/code&gt;_.
It is used only when the application has trapped an error and is
attempting to display an error message to the browser.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;start_response&lt;/code&gt; callable must return a &lt;code&gt;write(body_data)&lt;/code&gt;
callable that takes one positional parameter: a string to be written
as part of the HTTP response body.  (Note: the &lt;code&gt;write()&lt;/code&gt; callable is
provided only to support certain existing frameworks’ imperative output
APIs; it should not be used by new applications or frameworks if it
can be avoided.  See the &lt;code&gt;Buffering and Streaming&lt;/code&gt;_ section for more
details.)&lt;/p&gt;

&lt;p&gt;When called by the server, the application object must return an
iterable yielding zero or more strings.  This can be accomplished in a
variety of ways, such as by returning a list of strings, or by the
application being a generator function that yields strings, or
by the application being a class whose instances are iterable.
Regardless of how it is accomplished, the application object must
always return an iterable yielding zero or more strings.&lt;/p&gt;

&lt;p&gt;The server or gateway must transmit the yielded strings to the client
in an unbuffered fashion, completing the transmission of each string
before requesting another one.  (In other words, applications
&lt;strong&gt;should&lt;/strong&gt; perform their own buffering.  See the &lt;code&gt;Buffering and
Streaming&lt;/code&gt;_ section below for more on how application output must be
handled.)&lt;/p&gt;

&lt;p&gt;The server or gateway should treat the yielded strings as binary byte
sequences: in particular, it should ensure that line endings are
not altered.  The application is responsible for ensuring that the
string(s) to be written are in a format suitable for the client.  (The
server or gateway &lt;strong&gt;may&lt;/strong&gt; apply HTTP transfer encodings, or perform
other transformations for the purpose of implementing HTTP features
such as byte-range transmission.  See &lt;code&gt;Other HTTP Features&lt;/code&gt;_, below,
for more details.)&lt;/p&gt;

&lt;p&gt;If a call to &lt;code&gt;len(iterable)&lt;/code&gt; succeeds, the server must be able
to rely on the result being accurate.  That is, if the iterable
returned by the application provides a working &lt;code&gt;__len__()&lt;/code&gt;
method, it &lt;strong&gt;must&lt;/strong&gt; return an accurate result.  (See
the &lt;code&gt;Handling the Content-Length Header&lt;/code&gt;_ section for information
on how this would normally be used.)&lt;/p&gt;

&lt;p&gt;If the iterable returned by the application has a &lt;code&gt;close()&lt;/code&gt; method,
the server or gateway &lt;strong&gt;must&lt;/strong&gt; call that method upon completion of the
current request, whether the request was completed normally, or
terminated early due to an error.  (This is to support resource release
by the application.  This protocol is intended to complement PEP 325’s
generator support, and other common iterables with &lt;code&gt;close()&lt;/code&gt; methods.&lt;/p&gt;

&lt;p&gt;(Note: the application &lt;strong&gt;must&lt;/strong&gt; invoke the &lt;code&gt;start_response()&lt;/code&gt;
callable before the iterable yields its first body string, so that the
server can send the headers before any body content.  However, this
invocation &lt;strong&gt;may&lt;/strong&gt; be performed by the iterable’s first iteration, so
servers &lt;strong&gt;must not&lt;/strong&gt; assume that &lt;code&gt;start_response()&lt;/code&gt; has been called
before they begin iterating over the iterable.)&lt;/p&gt;

&lt;p&gt;Finally, servers and gateways &lt;strong&gt;must not&lt;/strong&gt; directly use any other
attributes of the iterable returned by the application, unless it is an
instance of a type specific to that server or gateway, such as a “file
wrapper” returned by &lt;code&gt;wsgi.file_wrapper&lt;/code&gt; (see &lt;code&gt;Optional
Platform-Specific File Handling&lt;/code&gt;_).  In the general case, only
attributes specified here, or accessed via e.g. the PEP 234 iteration
APIs are acceptable.&lt;/p&gt;

&lt;h2 id=&quot;environ-variables&quot;&gt;&lt;code&gt;environ&lt;/code&gt; Variables&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;environ&lt;/code&gt; dictionary is required to contain these CGI
environment variables, as defined by the Common Gateway Interface
specification [2]_.  The following variables &lt;strong&gt;must&lt;/strong&gt; be present,
unless their value would be an empty string, in which case they
&lt;strong&gt;may&lt;/strong&gt; be omitted, except as otherwise noted below.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;REQUEST_METHOD&lt;/code&gt;
  The HTTP request method, such as &lt;code&gt;&quot;GET&quot;&lt;/code&gt; or &lt;code&gt;&quot;POST&quot;&lt;/code&gt;.  This
  cannot ever be an empty string, and so is always required.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SCRIPT_NAME&lt;/code&gt;
  The initial portion of the request URL’s “path” that corresponds to
  the application object, so that the application knows its virtual
  “location”.  This &lt;strong&gt;may&lt;/strong&gt; be an empty string, if the application
  corresponds to the “root” of the server.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PATH_INFO&lt;/code&gt;
  The remainder of the request URL’s “path”, designating the virtual
  “location” of the request’s target within the application.  This
  &lt;strong&gt;may&lt;/strong&gt; be an empty string, if the request URL targets the
  application root and does not have a trailing slash.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;QUERY_STRING&lt;/code&gt;
  The portion of the request URL that follows the &lt;code&gt;&quot;?&quot;&lt;/code&gt;, if any.
  May be empty or absent.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CONTENT_TYPE&lt;/code&gt;
  The contents of any &lt;code&gt;Content-Type&lt;/code&gt; fields in the HTTP request.
  May be empty or absent.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CONTENT_LENGTH&lt;/code&gt;
  The contents of any &lt;code&gt;Content-Length&lt;/code&gt; fields in the HTTP request.
  May be empty or absent.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SERVER_NAME&lt;/code&gt;, &lt;code&gt;SERVER_PORT&lt;/code&gt;
  When combined with &lt;code&gt;SCRIPT_NAME&lt;/code&gt; and &lt;code&gt;PATH_INFO&lt;/code&gt;, these variables
  can be used to complete the URL.  Note, however, that &lt;code&gt;HTTP_HOST&lt;/code&gt;,
  if present, should be used in   preference to &lt;code&gt;SERVER_NAME&lt;/code&gt; for
  reconstructing the request URL.  See the &lt;code&gt;URL Reconstruction&lt;/code&gt;_
  section below for more detail.   &lt;code&gt;SERVER_NAME&lt;/code&gt; and &lt;code&gt;SERVER_PORT&lt;/code&gt;
  can never be empty strings, and so are always required.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SERVER_PROTOCOL&lt;/code&gt;
  The version of the protocol the client used to send the request.
  Typically this will be something like &lt;code&gt;&quot;HTTP/1.0&quot;&lt;/code&gt; or &lt;code&gt;&quot;HTTP/1.1&quot;&lt;/code&gt;
  and may be used by the application to determine how to treat any
  HTTP request headers.  (This variable should probably be called
  &lt;code&gt;REQUEST_PROTOCOL&lt;/code&gt;, since it denotes the protocol used in the
  request, and is not necessarily the protocol that will be used in the
  server’s response.  However, for compatibility with CGI we have to
  keep the existing name.)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HTTP_&lt;/code&gt; Variables
  Variables corresponding to the client-supplied HTTP request headers
  (i.e., variables whose names begin with &lt;code&gt;&quot;HTTP_&quot;&lt;/code&gt;).  The presence or
  absence of these variables should correspond with the presence or
  absence of the appropriate HTTP header in the request.&lt;/p&gt;

&lt;p&gt;A server or gateway &lt;strong&gt;should&lt;/strong&gt; attempt to provide as many other CGI
variables as are applicable.  In addition, if SSL is in use, the server
or gateway &lt;strong&gt;should&lt;/strong&gt; also provide as many of the Apache SSL environment
variables [5]_ as are applicable, such as &lt;code&gt;HTTPS=on&lt;/code&gt; and
&lt;code&gt;SSL_PROTOCOL&lt;/code&gt;.  Note, however, that an application that uses any CGI
variables other than the ones listed above are necessarily non-portable
to web servers that do not support the relevant extensions.  (For
example, web servers that do not publish files will not be able to
provide a meaningful &lt;code&gt;DOCUMENT_ROOT&lt;/code&gt; or &lt;code&gt;PATH_TRANSLATED&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;A WSGI-compliant server or gateway &lt;strong&gt;should&lt;/strong&gt; document what variables
it provides, along with their definitions as appropriate.  Applications
&lt;strong&gt;should&lt;/strong&gt; check for the presence of any variables they require, and
have a fallback plan in the event such a variable is absent.&lt;/p&gt;

&lt;p&gt;Note: missing variables (such as &lt;code&gt;REMOTE_USER&lt;/code&gt; when no
authentication has occurred) should be left out of the &lt;code&gt;environ&lt;/code&gt;
dictionary.  Also note that CGI-defined variables must be strings,
if they are present at all.  It is a violation of this specification
for a CGI variable’s value to be of any type other than &lt;code&gt;str&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In addition to the CGI-defined variables, the &lt;code&gt;environ&lt;/code&gt; dictionary
&lt;strong&gt;may&lt;/strong&gt; also contain arbitrary operating-system “environment variables”,
and &lt;strong&gt;must&lt;/strong&gt; contain the following WSGI-defined variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;=====================  ===============================================
Variable               Value
=====================  ===============================================
``wsgi.version``       The tuple ``(1, 0)``, representing WSGI
                       version 1.0.

``wsgi.url_scheme``    A string representing the &quot;scheme&quot; portion of
                       the URL at which the application is being
                       invoked.  Normally, this will have the value
                       ``&quot;http&quot;`` or ``&quot;https&quot;``, as appropriate.

``wsgi.input``         An input stream (file-like object) from which
                       the HTTP request body can be read.  (The server
                       or gateway may perform reads on-demand as
                       requested by the application, or it may pre-
                       read the client&#39;s request body and buffer it
                       in-memory or on disk, or use any other
                       technique for providing such an input stream,
                       according to its preference.)

``wsgi.errors``        An output stream (file-like object) to which
                       error output can be written, for the purpose of
                       recording program or other errors in a
                       standardized and possibly centralized location.
                       This should be a &quot;text mode&quot; stream; i.e.,
                       applications should use ``&quot;\n&quot;`` as a line
                       ending, and assume that it will be converted to
                       the correct line ending by the server/gateway.

                       For many servers, ``wsgi.errors`` will be the
                       server&#39;s main error log. Alternatively, this
                       may be ``sys.stderr``, or a log file of some
                       sort.  The server&#39;s documentation should
                       include an explanation of how to configure this
                       or where to find the recorded output.  A server
                       or gateway may supply different error streams
                       to different applications, if this is desired.

``wsgi.multithread``   This value should evaluate true if the
                       application object may be simultaneously
                       invoked by another thread in the same process,
                       and should evaluate false otherwise.

``wsgi.multiprocess``  This value should evaluate true if an
                       equivalent application object may be
                       simultaneously invoked by another process,
                       and should evaluate false otherwise.

``wsgi.run_once``      This value should evaluate true if the server
                       or gateway expects (but does not guarantee!)
                       that the application will only be invoked this
                       one time during the life of its containing
                       process.  Normally, this will only be true for
                       a gateway based on CGI (or something similar).
=====================  ===============================================
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the &lt;code&gt;environ&lt;/code&gt; dictionary may also contain server-defined
variables.  These variables should be named using only lower-case
letters, numbers, dots, and underscores, and should be prefixed with
a name that is unique to the defining server or gateway.  For
example, &lt;code&gt;mod_python&lt;/code&gt; might define variables with names like
&lt;code&gt;mod_python.some_variable&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;input-and-error-streams&quot;&gt;Input and Error Streams&lt;/h1&gt;

&lt;p&gt;The input and error streams provided by the server must support
the following methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;===================  ==========  ========
Method               Stream      Notes
===================  ==========  ========
``read(size)``       ``input``   1
``readline()``       ``input``   1, 2
``readlines(hint)``  ``input``   1, 3
``__iter__()``       ``input``
``flush()``          ``errors``  4
``write(str)``       ``errors``
``writelines(seq)``  ``errors``
===================  ==========  ========
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The semantics of each method are as documented in the Python Library
Reference, except for these notes as listed in the table above:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The server is not required to read past the client’s specified
&lt;code&gt;Content-Length&lt;/code&gt;, and is allowed to simulate an end-of-file
condition if the application attempts to read past that point.
The application &lt;strong&gt;should not&lt;/strong&gt; attempt to read more data than is
specified by the &lt;code&gt;CONTENT_LENGTH&lt;/code&gt; variable.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The optional “size” argument to &lt;code&gt;readline()&lt;/code&gt; is not supported,
as it may be complex for server authors to implement, and is not
often used in practice.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Note that the &lt;code&gt;hint&lt;/code&gt; argument to &lt;code&gt;readlines()&lt;/code&gt; is optional for
both caller and implementer.  The application is free not to
supply it, and the server or gateway is free to ignore it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Since the &lt;code&gt;errors&lt;/code&gt; stream may not be rewound, servers and gateways
are free to forward write operations immediately, without buffering.
In this case, the &lt;code&gt;flush()&lt;/code&gt; method may be a no-op.  Portable
applications, however, cannot assume that output is unbuffered
or that &lt;code&gt;flush()&lt;/code&gt; is a no-op.  They must call &lt;code&gt;flush()&lt;/code&gt; if
they need to ensure that output has in fact been written.  (For
example, to minimize intermingling of data from multiple processes
writing to the same error log.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The methods listed in the table above &lt;strong&gt;must&lt;/strong&gt; be supported by all
servers conforming to this specification.  Applications conforming
to this specification &lt;strong&gt;must not&lt;/strong&gt; use any other methods or attributes
of the &lt;code&gt;input&lt;/code&gt; or &lt;code&gt;errors&lt;/code&gt; objects.  In particular, applications
&lt;strong&gt;must not&lt;/strong&gt; attempt to close these streams, even if they possess
&lt;code&gt;close()&lt;/code&gt; methods.&lt;/p&gt;

&lt;h2 id=&quot;the-startresponse-callable&quot;&gt;The &lt;code&gt;start_response()&lt;/code&gt; Callable&lt;/h2&gt;

&lt;p&gt;The second parameter passed to the application object is a callable
of the form &lt;code&gt;start_response(status, response_headers, exc_info=None)&lt;/code&gt;.
(As with all WSGI callables, the arguments must be supplied
positionally, not by keyword.)  The &lt;code&gt;start_response&lt;/code&gt; callable is
used to begin the HTTP response, and it must return a
&lt;code&gt;write(body_data)&lt;/code&gt; callable (see the &lt;code&gt;Buffering and Streaming&lt;/code&gt;_
section, below).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;status&lt;/code&gt; argument is an HTTP “status” string like &lt;code&gt;&quot;200 OK&quot;&lt;/code&gt;
or &lt;code&gt;&quot;404 Not Found&quot;&lt;/code&gt;.  That is, it is a string consisting of a
Status-Code and a Reason-Phrase, in that order and separated by a
single space, with no surrounding whitespace or other characters.
(See RFC 2616, Section 6.1.1 for more information.)  The string
&lt;strong&gt;must not&lt;/strong&gt; contain control characters, and must not be terminated
with a carriage return, linefeed, or combination thereof.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;response_headers&lt;/code&gt; argument is a list of &lt;code&gt;(header_name,
header_value)&lt;/code&gt; tuples.  It must be a Python list; i.e.
&lt;code&gt;type(response_headers) is ListType&lt;/code&gt;, and the server &lt;strong&gt;may&lt;/strong&gt; change
its contents in any way it desires.  Each &lt;code&gt;header_name&lt;/code&gt; must be a
valid HTTP header field-name (as defined by RFC 2616, Section 4.2),
without a trailing colon or other punctuation.&lt;/p&gt;

&lt;p&gt;Each &lt;code&gt;header_value&lt;/code&gt; &lt;strong&gt;must not&lt;/strong&gt; include &lt;em&gt;any&lt;/em&gt; control characters,
including carriage returns or linefeeds, either embedded or at the end.
(These requirements are to minimize the complexity of any parsing that
must be performed by servers, gateways, and intermediate response
processors that need to inspect or modify response headers.)&lt;/p&gt;

&lt;p&gt;In general, the server or gateway is responsible for ensuring that
correct headers are sent to the client: if the application omits
a header required by HTTP (or other relevant specifications that are in
effect), the server or gateway &lt;strong&gt;must&lt;/strong&gt; add it.  For example, the HTTP
&lt;code&gt;Date:&lt;/code&gt; and &lt;code&gt;Server:&lt;/code&gt; headers would normally be supplied by the
server or gateway.&lt;/p&gt;

&lt;p&gt;(A reminder for server/gateway authors: HTTP header names are
case-insensitive, so be sure to take that into consideration when
examining application-supplied headers!)&lt;/p&gt;

&lt;p&gt;Applications and middleware are forbidden from using HTTP/1.1
“hop-by-hop” features or headers, any equivalent features in HTTP/1.0,
or any headers that would affect the persistence of the client’s
connection to the web server.  These features are the
exclusive province of the actual web server, and a server or gateway
&lt;strong&gt;should&lt;/strong&gt; consider it a fatal error for an application to attempt
sending them, and raise an error if they are supplied to
&lt;code&gt;start_response()&lt;/code&gt;.  (For more specifics on “hop-by-hop” features and
headers, please see the &lt;code&gt;Other HTTP Features&lt;/code&gt;_ section below.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;start_response&lt;/code&gt; callable &lt;strong&gt;must not&lt;/strong&gt; actually transmit the
response headers.  Instead, it must store them for the server or
gateway to transmit &lt;strong&gt;only&lt;/strong&gt; after the first iteration of the
application return value that yields a non-empty string, or upon
the application’s first invocation of the &lt;code&gt;write()&lt;/code&gt; callable.  In
other words, response headers must not be sent until there is actual
body data available, or until the application’s returned iterable is
exhausted.  (The only possible exception to this rule is if the
response headers explicitly include a &lt;code&gt;Content-Length&lt;/code&gt; of zero.)&lt;/p&gt;

&lt;p&gt;This delaying of response header transmission is to ensure that buffered
and asynchronous applications can replace their originally intended
output with error output, up until the last possible moment.  For
example, the application may need to change the response status from
“200 OK” to “500 Internal Error”, if an error occurs while the body is
being generated within an application buffer.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;exc_info&lt;/code&gt; argument, if supplied, must be a Python
&lt;code&gt;sys.exc_info()&lt;/code&gt; tuple.  This argument should be supplied by the
application only if &lt;code&gt;start_response&lt;/code&gt; is being called by an error
handler.  If &lt;code&gt;exc_info&lt;/code&gt; is supplied, and no HTTP headers have been
output yet, &lt;code&gt;start_response&lt;/code&gt; should replace the currently-stored
HTTP response headers with the newly-supplied ones, thus allowing the
application to “change its mind” about the output when an error has
occurred.&lt;/p&gt;

&lt;p&gt;However, if &lt;code&gt;exc_info&lt;/code&gt; is provided, and the HTTP headers have already
been sent, &lt;code&gt;start_response&lt;/code&gt; &lt;strong&gt;must&lt;/strong&gt; raise an error, and &lt;strong&gt;should&lt;/strong&gt;
raise the &lt;code&gt;exc_info&lt;/code&gt; tuple.  That is::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;raise exc_info[0], exc_info[1], exc_info[2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will re-raise the exception trapped by the application, and in
principle should abort the application.  (It is not safe for the
application to attempt error output to the browser once the HTTP
headers have already been sent.)  The application &lt;strong&gt;must not&lt;/strong&gt; trap
any exceptions raised by &lt;code&gt;start_response&lt;/code&gt;, if it called
&lt;code&gt;start_response&lt;/code&gt; with &lt;code&gt;exc_info&lt;/code&gt;.  Instead, it should allow
such exceptions to propagate back to the server or gateway.  See
&lt;code&gt;Error Handling&lt;/code&gt;_ below, for more details.&lt;/p&gt;

&lt;p&gt;The application &lt;strong&gt;may&lt;/strong&gt; call &lt;code&gt;start_response&lt;/code&gt; more than once, if and
only if the &lt;code&gt;exc_info&lt;/code&gt; argument is provided.  More precisely, it is
a fatal error to call &lt;code&gt;start_response&lt;/code&gt; without the &lt;code&gt;exc_info&lt;/code&gt;
argument if &lt;code&gt;start_response&lt;/code&gt; has already been called within the
current invocation of the application.  (See the example CGI
gateway above for an illustration of the correct logic.)&lt;/p&gt;

&lt;p&gt;Note: servers, gateways, or middleware implementing &lt;code&gt;start_response&lt;/code&gt;
&lt;strong&gt;should&lt;/strong&gt; ensure that no reference is held to the &lt;code&gt;exc_info&lt;/code&gt;
parameter beyond the duration of the function’s execution, to avoid
creating a circular reference through the traceback and frames
involved.  The simplest way to do this is something like::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def start_response(status, response_headers, exc_info=None):
    if exc_info:
         try:
             # do stuff w/exc_info here
         finally:
             exc_info = None    # Avoid circular ref.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example CGI gateway provides another illustration of this
technique.&lt;/p&gt;

&lt;h1 id=&quot;handling-the-content-length-header&quot;&gt;Handling the &lt;code&gt;Content-Length&lt;/code&gt; Header&lt;/h1&gt;

&lt;p&gt;If the application does not supply a &lt;code&gt;Content-Length&lt;/code&gt; header, a
server or gateway may choose one of several approaches to handling
it.  The simplest of these is to close the client connection when
the response is completed.&lt;/p&gt;

&lt;p&gt;Under some circumstances, however, the server or gateway may be
able to either generate a &lt;code&gt;Content-Length&lt;/code&gt; header, or at least
avoid the need to close the client connection.  If the application
does &lt;em&gt;not&lt;/em&gt; call the &lt;code&gt;write()&lt;/code&gt; callable, and returns an iterable
whose &lt;code&gt;len()&lt;/code&gt; is 1, then the server can automatically determine
&lt;code&gt;Content-Length&lt;/code&gt; by taking the length of the first string yielded
by the iterable.&lt;/p&gt;

&lt;p&gt;And, if the server and client both support HTTP/1.1 “chunked
encoding” [3]_, then the server &lt;strong&gt;may&lt;/strong&gt; use chunked encoding to send
a chunk for each &lt;code&gt;write()&lt;/code&gt; call or string yielded by the iterable,
thus generating a &lt;code&gt;Content-Length&lt;/code&gt; header for each chunk.  This
allows the server to keep the client connection alive, if it wishes
to do so.  Note that the server &lt;strong&gt;must&lt;/strong&gt; comply fully with RFC 2616
when doing this, or else fall back to one of the other strategies for
dealing with the absence of &lt;code&gt;Content-Length&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(Note: applications and middleware &lt;strong&gt;must not&lt;/strong&gt; apply any kind of
&lt;code&gt;Transfer-Encoding&lt;/code&gt; to their output, such as chunking or gzipping;
as “hop-by-hop” operations, these encodings are the province of the
actual web server/gateway.  See &lt;code&gt;Other HTTP Features&lt;/code&gt;_ below, for
more details.)&lt;/p&gt;

&lt;h2 id=&quot;buffering-and-streaming&quot;&gt;Buffering and Streaming&lt;/h2&gt;

&lt;p&gt;Generally speaking, applications will achieve the best throughput
by buffering their (modestly-sized) output and sending it all at
once.  This is a common approach in existing frameworks such as
Zope: the output is buffered in a StringIO or similar object, then
transmitted all at once, along with the response headers.&lt;/p&gt;

&lt;p&gt;The corresponding approach in WSGI is for the application to simply
return a single-element iterable (such as a list) containing the
response body as a single string.  This is the recommended approach
for the vast majority of application functions, that render
HTML pages whose text easily fits in memory.&lt;/p&gt;

&lt;p&gt;For large files, however, or for specialized uses of HTTP streaming
(such as multipart “server push”), an application may need to provide
output in smaller blocks (e.g. to avoid loading a large file into
memory).  It’s also sometimes the case that part of a response may
be time-consuming to produce, but it would be useful to send ahead the
portion of the response that precedes it.&lt;/p&gt;

&lt;p&gt;In these cases, applications will usually return an iterator (often
a generator-iterator) that produces the output in a block-by-block
fashion.  These blocks may be broken to coincide with mulitpart
boundaries (for “server push”), or just before time-consuming
tasks (such as reading another block of an on-disk file).&lt;/p&gt;

&lt;p&gt;WSGI servers, gateways, and middleware &lt;strong&gt;must not&lt;/strong&gt; delay the
transmission of any block; they &lt;strong&gt;must&lt;/strong&gt; either fully transmit
the block to the client, or guarantee that they will continue
transmission even while the application is producing its next block.
A server/gateway or middleware may provide this guarantee in one of
three ways:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Send the entire block to the operating system (and request
that any O/S buffers be flushed) before returning control
to the application, OR&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use a different thread to ensure that the block continues
to be transmitted while the application produces the next
block.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(Middleware only) send the entire block to its parent
gateway/server&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By providing this guarantee, WSGI allows applications to ensure
that transmission will not become stalled at an arbitrary point
in their output data.  This is critical for proper functioning
of e.g. multipart “server push” streaming, where data between
multipart boundaries should be transmitted in full to the client.&lt;/p&gt;

&lt;p&gt;Middleware Handling of Block Boundaries&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In order to better support asynchronous applications and servers,
middleware components **must not** block iteration waiting for
multiple values from an application iterable.  If the middleware
needs to accumulate more data from the application before it can
produce any output, it **must*The second parameter passed * yield an empty string.

To put this requirement another way, a middleware component **must
yield at least one value** each time its underlying application
yields a value.  If the middleware cannot yield any other value,
it must yield an empty string.

This requirement ensures that asynchronous applications and servers
can conspire to reduce the number of threads that are required
to run a given number of application instances simultaneously.

Note also that this requirement means that middleware **must**
return an iterable as soon as its underlying application returns
an iterable.  It is also forbidden for middleware to use the
``write()`` callable to transmit data that is yielded by an
underlying application.  Middleware may only use their parent
server&#39;s ``write()`` callable to transmit data that the
underlying application sent using a middleware-provided ``write()``
callable.


The ``write()`` Callable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some existing application framework APIs support unbuffered
output in a different manner than WSGI.  Specifically, they
provide a “write” function or method of some kind to write
an unbuffered block of data, or else they provide a buffered
“write” function and a “flush” mechanism to flush the buffer.&lt;/p&gt;

&lt;p&gt;Unfortunately, such APIs cannot be implemented in terms of
WSGI’s “iterable” application return value, unless threads
or other special mechanisms are used.&lt;/p&gt;

&lt;p&gt;Therefore, to allow these frameworks to continue using an
imperative API, WSGI includes a special &lt;code&gt;write()&lt;/code&gt; callable,
returned by the &lt;code&gt;start_response&lt;/code&gt; callable.&lt;/p&gt;

&lt;p&gt;New WSGI applications and frameworks &lt;strong&gt;should not&lt;/strong&gt; use the
&lt;code&gt;write()&lt;/code&gt; callable if it is possible to avoid doing so.  The
&lt;code&gt;write()&lt;/code&gt; callable is strictly a hack to support imperative
streaming APIs.  In general, applications should produce their
output via their returned iterable, as this makes it possible
for web servers to interleave other tasks in the same Python thread,
potentially providing better throughput for the server as a whole.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;write()&lt;/code&gt; callable is returned by the &lt;code&gt;start_response()&lt;/code&gt;
callable, and it accepts a single parameter:  a string to be
written as part of the HTTP response body, that is treated exactly
as though it had been yielded by the output iterable.  In other
words, before &lt;code&gt;write()&lt;/code&gt; returns, it must guarantee that the
passed-in string was either completely sent to the client, or
that it is buffered for transmission while the application
proceeds onward.&lt;/p&gt;

&lt;p&gt;An application &lt;strong&gt;must&lt;/strong&gt; return an iterable object, even if it
uses &lt;code&gt;write()&lt;/code&gt; to produce all or part of its response body.
The returned iterable &lt;strong&gt;may&lt;/strong&gt; be empty (i.e. yield no non-empty
strings), but if it &lt;em&gt;does&lt;/em&gt; yield non-empty strings, that output
must be treated normally by the server or gateway (i.e., it must be
sent or queued immediately).  Applications &lt;strong&gt;must not&lt;/strong&gt; invoke
&lt;code&gt;write()&lt;/code&gt; from within their return iterable, and therefore any
strings yielded by the iterable are transmitted after all strings
passed to &lt;code&gt;write()&lt;/code&gt; have been sent to the client.&lt;/p&gt;

&lt;h2 id=&quot;unicode-issues&quot;&gt;Unicode Issues&lt;/h2&gt;

&lt;p&gt;HTTP does not directly support Unicode, and neither does this
interface.  All encoding/decoding must be handled by the application;
all strings passed to or from the server must be standard Python byte
strings, not Unicode objects.  The result of using a Unicode object
where a string object is required, is undefined.&lt;/p&gt;

&lt;p&gt;Note also that strings passed to &lt;code&gt;start_response()&lt;/code&gt; as a status or
as response headers &lt;strong&gt;must&lt;/strong&gt; follow RFC 2616 with respect to encoding.
That is, they must either be ISO-8859-1 characters, or use RFC 2047
MIME encoding.&lt;/p&gt;

&lt;p&gt;On Python platforms where the &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;StringType&lt;/code&gt; type is in
fact Unicode-based (e.g. Jython, IronPython, Python 3000, etc.), all
“strings” referred to in this specification must contain only
code points representable in ISO-8859-1 encoding (&lt;code&gt;\u0000&lt;/code&gt; through
&lt;code&gt;\u00FF&lt;/code&gt;, inclusive).  It is a fatal error for an application to
supply strings containing any other Unicode character or code point.
Similarly, servers and gateways &lt;strong&gt;must not&lt;/strong&gt; supply
strings to an application containing any other Unicode characters.&lt;/p&gt;

&lt;p&gt;Again, all strings referred to in this specification &lt;strong&gt;must&lt;/strong&gt; be
of type &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;StringType&lt;/code&gt;, and &lt;strong&gt;must not&lt;/strong&gt; be of type
&lt;code&gt;unicode&lt;/code&gt; or &lt;code&gt;UnicodeType&lt;/code&gt;.  And, even if a given platform allows
for more than 8 bits per character in &lt;code&gt;str&lt;/code&gt;/&lt;code&gt;StringType&lt;/code&gt; objects,
only the lower 8 bits may be used, for any value referred to in
this specification as a “string”.&lt;/p&gt;

&lt;h2 id=&quot;error-handling&quot;&gt;Error Handling&lt;/h2&gt;

&lt;p&gt;In general, applications &lt;strong&gt;should&lt;/strong&gt; try to trap their own, internal
errors, and display a helpful message in the browser.  (It is up
to the application to decide what “helpful” means in this context.)&lt;/p&gt;

&lt;p&gt;However, to display such a message, the application must not have
actually sent any data to the browser yet, or else it risks corrupting
the response.  WSGI therefore provides a mechanism to either allow the
application to send its error message, or be automatically aborted:
the &lt;code&gt;exc_info&lt;/code&gt; argument to &lt;code&gt;start_response&lt;/code&gt;.  Here is an example
of its use::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try:
    # regular application code here
    status = &quot;200 Froody&quot;
    response_headers = [(&quot;content-type&quot;, &quot;text/plain&quot;)]
    start_response(status, response_headers)
    return [&quot;normal body goes here&quot;]
except:
    # XXX should trap runtime issues like MemoryError, KeyboardInterrupt
    #     in a separate handler before this bare &#39;except:&#39;...
    status = &quot;500 Oops&quot;
    response_headers = [(&quot;content-type&quot;, &quot;text/plain&quot;)]
    start_response(status, response_headers, sys.exc_info())
    return [&quot;error body goes here&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If no output has been written when an exception occurs, the call to
&lt;code&gt;start_response&lt;/code&gt; will return normally, and the application will
return an error body to be sent to the browser.  However, if any output
has already been sent to the browser, &lt;code&gt;start_response&lt;/code&gt; will reraise
the provided exception.  This exception &lt;strong&gt;should not&lt;/strong&gt; be trapped by
the application, and so the application will abort.  The server or
gateway can then trap this (fatal) exception and abort the response.&lt;/p&gt;

&lt;p&gt;Servers &lt;strong&gt;should&lt;/strong&gt; trap and log any exception that aborts an
application or the iteration of its return value.  If a partial
response has already been written to the browser when an application
error occurs, the server or gateway &lt;strong&gt;may&lt;/strong&gt; attempt to add an error
message to the output, if the already-sent headers indicate a
&lt;code&gt;text/*&lt;/code&gt; content type that the server knows how to modify cleanly.&lt;/p&gt;

&lt;p&gt;Some middleware may wish to provide additional exception handling
services, or intercept and replace application error messages.  In
such cases, middleware may choose to &lt;strong&gt;not&lt;/strong&gt; re-raise the &lt;code&gt;exc_info&lt;/code&gt;
supplied to &lt;code&gt;start_response&lt;/code&gt;, but instead raise a middleware-specific
exception, or simply return without an exception after storing the
supplied arguments.  This will then cause the application to return
its error body iterable (or invoke &lt;code&gt;write()&lt;/code&gt;), allowing the middleware
to capture and modify the error output.  These techniques will work as
long as application authors:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Always provide &lt;code&gt;exc_info&lt;/code&gt; when beginning an error response&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Never trap errors raised by &lt;code&gt;start_response&lt;/code&gt; when &lt;code&gt;exc_info&lt;/code&gt; is
being provided&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;http-11-expectcontinue&quot;&gt;HTTP 1.1 Expect/Continue&lt;/h2&gt;

&lt;p&gt;Servers and gateways that implement HTTP 1.1 &lt;strong&gt;must&lt;/strong&gt; provide
transparent support for HTTP 1.1’s “expect/continue” mechanism.  This
may be done in any of several ways:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Respond to requests containing an &lt;code&gt;Expect: 100-continue&lt;/code&gt; request
with an immediate “100 Continue” response, and proceed normally.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Proceed with the request normally, but provide the application
with a &lt;code&gt;wsgi.input&lt;/code&gt; stream that will send the “100 Continue”
response if/when the application first attempts to read from the
input stream.  The read request must then remain blocked until the
client responds.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Wait until the client decides that the server does not support
expect/continue, and sends the request body on its own.  (This
is suboptimal, and is not recommended.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note that these behavior restrictions do not apply for HTTP 1.0
requests, or for requests that are not directed to an application
object.  For more information on HTTP 1.1 Expect/Continue, see RFC
2616, sections 8.2.3 and 10.1.1.&lt;/p&gt;

&lt;h2 id=&quot;other-http-features&quot;&gt;Other HTTP Features&lt;/h2&gt;

&lt;p&gt;In general, servers and gateways should “play dumb” and allow the
application complete control over its output.  They should only make
changes that do not alter the effective semantics of the application’s
response.  It is always possible for the application developer to add
middleware components to supply additional features, so server/gateway
developers should be conservative in their implementation.  In a sense,
a server should consider itself to be like an HTTP “gateway server”,
with the application being an HTTP “origin server”.  (See RFC 2616,
section 1.3, for the definition of these terms.)&lt;/p&gt;

&lt;p&gt;However, because WSGI servers and applications do not communicate via
HTTP, what RFC 2616 calls “hop-by-hop” headers do not apply to WSGI
internal communications.  WSGI applications &lt;strong&gt;must not&lt;/strong&gt; generate any
“hop-by-hop” headers [4]_, attempt to use HTTP features that would
require them to generate such headers, or rely on the content of
any incoming “hop-by-hop” headers in the &lt;code&gt;environ&lt;/code&gt; dictionary.
WSGI servers &lt;strong&gt;must&lt;/strong&gt; handle any supported inbound “hop-by-hop” headers
on their own, such as by decoding any inbound &lt;code&gt;Transfer-Encoding&lt;/code&gt;,
including chunked encoding if applicable.&lt;/p&gt;

&lt;p&gt;Applying these principles to a variety of HTTP features, it should be
clear that a server &lt;strong&gt;may&lt;/strong&gt; handle cache validation via the
&lt;code&gt;If-None-Match&lt;/code&gt; and &lt;code&gt;If-Modified-Since&lt;/code&gt; request headers and the
&lt;code&gt;Last-Modified&lt;/code&gt; and &lt;code&gt;ETag&lt;/code&gt; response headers.  However, it is
not required to do this, and the application &lt;strong&gt;should&lt;/strong&gt; perform its
own cache validation if it wants to support that feature, since
the server/gateway is not required to do such validation.&lt;/p&gt;

&lt;p&gt;Similarly, a server &lt;strong&gt;may&lt;/strong&gt; re-encode or transport-encode an
application’s response, but the application &lt;strong&gt;should&lt;/strong&gt; use a
suitable content encoding on its own, and &lt;strong&gt;must not&lt;/strong&gt; apply a
transport encoding.  A server &lt;strong&gt;may&lt;/strong&gt; transmit byte ranges of the
application’s response if requested by the client, and the
application doesn’t natively support byte ranges.  Again, however,
the application &lt;strong&gt;should&lt;/strong&gt; perform this function on its own if desired.&lt;/p&gt;

&lt;p&gt;Note that these restrictions on applications do not necessarily mean
that every application must reimplement every HTTP feature; many HTTP
features can be partially or fully implemented by middleware
components, thus freeing both server and application authors from
implementing the same features over and over again.&lt;/p&gt;

&lt;h2 id=&quot;thread-support&quot;&gt;Thread Support&lt;/h2&gt;

&lt;p&gt;Thread support, or lack thereof, is also server-dependent.
Servers that can run multiple requests in parallel, &lt;strong&gt;should&lt;/strong&gt; also
provide the option of running an application in a single-threaded
fashion, so that applications or frameworks that are not thread-safe
may still be used with that server.&lt;/p&gt;

&lt;h1 id=&quot;implementationapplication-notes&quot;&gt;Implementation/Application Notes&lt;/h1&gt;

&lt;h2 id=&quot;server-extension-apis&quot;&gt;Server Extension APIs&lt;/h2&gt;

&lt;p&gt;Some server authors may wish to expose more advanced APIs, that
application or framework authors can use for specialized purposes.
For example, a gateway based on &lt;code&gt;mod_python&lt;/code&gt; might wish to expose
part of the Apache API as a WSGI extension.&lt;/p&gt;

&lt;p&gt;In the simplest case, this requires nothing more than defining an
&lt;code&gt;environ&lt;/code&gt; variable, such as &lt;code&gt;mod_python.some_api&lt;/code&gt;.  But, in many
cases, the possible presence of middleware can make this difficult.
For example, an API that offers access to the same HTTP headers that
are found in &lt;code&gt;environ&lt;/code&gt; variables, might return different data if
&lt;code&gt;environ&lt;/code&gt; has been modified by middleware.&lt;/p&gt;

&lt;p&gt;In general, any extension API that duplicates, supplants, or bypasses
some portion of WSGI functionality runs the risk of being incompatible
with middleware components.  Server/gateway developers should &lt;em&gt;not&lt;/em&gt;
assume that nobody will use middleware, because some framework
developers specifically intend to organize or reorganize their
frameworks to function almost entirely as middleware of various kinds.&lt;/p&gt;

&lt;p&gt;So, to provide maximum compatibility, servers and gateways that
provide extension APIs that replace some WSGI functionality, &lt;strong&gt;must&lt;/strong&gt;
design those APIs so that they are invoked using the portion of the
API that they replace.  For example, an extension API to access HTTP
request headers must require the application to pass in its current
&lt;code&gt;environ&lt;/code&gt;, so that the server/gateway may verify that HTTP headers
accessible via the API have not been altered by middleware.  If the
extension API cannot guarantee that it will always agree with
&lt;code&gt;environ&lt;/code&gt; about the contents of HTTP headers, it must refuse service
to the application, e.g. by raising an error, returning &lt;code&gt;None&lt;/code&gt;
instead of a header collection, or whatever is appropriate to the API.&lt;/p&gt;

&lt;p&gt;Similarly, if an extension API provides an alternate means of writing
response data or headers, it should require the &lt;code&gt;start_response&lt;/code&gt;
callable to be passed in, before the application can obtain the
extended service.  If the object passed in is not the same one that
the server/gateway originally supplied to the application, it cannot
guarantee correct operation and must refuse to provide the extended
service to the application.&lt;/p&gt;

&lt;p&gt;These guidelines also apply to middleware that adds information such
as parsed cookies, form variables, sessions, and the like to
&lt;code&gt;environ&lt;/code&gt;.  Specifically, such middleware should provide these
features as functions which operate on &lt;code&gt;environ&lt;/code&gt;, rather than simply
stuffing values into &lt;code&gt;environ&lt;/code&gt;.  This helps ensure that information
is calculated from &lt;code&gt;environ&lt;/code&gt; &lt;em&gt;after&lt;/em&gt; any middleware has done any URL
rewrites or other &lt;code&gt;environ&lt;/code&gt; modifications.&lt;/p&gt;

&lt;p&gt;It is very important that these “safe extension” rules be followed by
both server/gateway and middleware developers, in order to avoid a
future in which middleware developers are forced to delete any and all
extension APIs from &lt;code&gt;environ&lt;/code&gt; to ensure that their mediation isn’t
being bypassed by applications using those extensions!&lt;/p&gt;

&lt;h2 id=&quot;application-configuration&quot;&gt;Application Configuration&lt;/h2&gt;

&lt;p&gt;This specification does not define how a server selects or obtains an
application to invoke.  These and other configuration options are
highly server-specific matters.  It is expected that server/gateway
authors will document how to configure the server to execute a
particular application object, and with what options (such as
threading options).&lt;/p&gt;

&lt;p&gt;Framework authors, on the other hand, should document how to create an
application object that wraps their framework’s functionality.  The
user, who has chosen both the server and the application framework,
must connect the two together.  However, since both the framework and
the server now have a common interface, this should be merely a
mechanical matter, rather than a significant engineering effort for
each new server/framework pair.&lt;/p&gt;

&lt;p&gt;Finally, some applications, frameworks, and middleware may wish to
use the &lt;code&gt;environ&lt;/code&gt; dictionary to receive simple string configuration
options.  Servers and gateways &lt;strong&gt;should&lt;/strong&gt; support this by allowing
an application’s deployer to specify name-value pairs to be placed in
&lt;code&gt;environ&lt;/code&gt;.  In the simplest case, this support can consist merely of
copying all operating system-supplied environment variables from
&lt;code&gt;os.environ&lt;/code&gt; into the &lt;code&gt;environ&lt;/code&gt; dictionary, since the deployer in
principle can configure these externally to the server, or in the
CGI case they may be able to be set via the server’s configuration
files.&lt;/p&gt;

&lt;p&gt;Applications &lt;strong&gt;should&lt;/strong&gt; try to keep such required variables to a
minimum, since not all servers will support easy configuration of
them.  Of course, even in the worst case, persons deploying an
application can create a script to supply the necessary configuration
values::&lt;/p&gt;

&lt;p&gt;from the_app import application&lt;/p&gt;

&lt;p&gt;def new_app(environ, start_response):
       environ[‘the_app.configval1’] = ‘something’
       return application(environ, start_response)&lt;/p&gt;

&lt;p&gt;But, most existing applications and frameworks will probably only need
a single configuration value from &lt;code&gt;environ&lt;/code&gt;, to indicate the location
of their application or framework-specific configuration file(s).  (Of
course, applications should cache such configuration, to avoid having
to re-read it upon each invocation.)&lt;/p&gt;

&lt;h2 id=&quot;url-reconstruction&quot;&gt;URL Reconstruction&lt;/h2&gt;

&lt;p&gt;If an application wishes to reconstruct a request’s complete URL, it
may do so using the following algorithm, contributed by Ian Bicking::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from urllib import quote
url = environ[&#39;wsgi.url_scheme&#39;]+&#39;://&#39;

if environ.get(&#39;HTTP_HOST&#39;):
    url += environ[&#39;HTTP_HOST&#39;]
else:
    url += environ[&#39;SERVER_NAME&#39;]

    if environ[&#39;wsgi.url_scheme&#39;] == &#39;https&#39;:
        if environ[&#39;SERVER_PORT&#39;] != &#39;443&#39;:
           url += &#39;:&#39; + environ[&#39;SERVER_PORT&#39;]
    else:
        if environ[&#39;SERVER_PORT&#39;] != &#39;80&#39;:
           url += &#39;:&#39; + environ[&#39;SERVER_PORT&#39;]

url += quote(environ.get(&#39;SCRIPT_NAME&#39;, &#39;&#39;))
url += quote(environ.get(&#39;PATH_INFO&#39;, &#39;&#39;))
if environ.get(&#39;QUERY_STRING&#39;):
    url += &#39;?&#39; + environ[&#39;QUERY_STRING&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that such a reconstructed URL may not be precisely the same URI
as requested by the client.  Server rewrite rules, for example, may
have modified the client’s originally requested URL to place it in a
canonical form.&lt;/p&gt;

&lt;h2 id=&quot;supporting-older-22-versions-of-python&quot;&gt;Supporting Older (&amp;lt;2.2) Versions of Python&lt;/h2&gt;

&lt;p&gt;Some servers, gateways, or applications may wish to support older
(&amp;lt;2.2) versions of Python.  This is especially important if Jython
is a target platform, since as of this writing a production-ready
version of Jython 2.2 is not yet available.&lt;/p&gt;

&lt;p&gt;For servers and gateways, this is relatively straightforward:
servers and gateways targeting pre-2.2 versions of Python must
simply restrict themselves to using only a standard “for” loop to
iterate over any iterable returned by an application.  This is the
only way to ensure source-level compatibility with both the pre-2.2
iterator protocol (discussed further below) and “today’s” iterator
protocol (see PEP 234).&lt;/p&gt;

&lt;p&gt;(Note that this technique necessarily applies only to servers,
gateways, or middleware that are written in Python.  Discussion of
how to use iterator protocol(s) correctly from other languages is
outside the scope of this PEP.)&lt;/p&gt;

&lt;p&gt;For applications, supporting pre-2.2 versions of Python is slightly
more complex:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;You may not return a file object and expect it to work as an iterable,
since before Python 2.2, files were not iterable.  (In general, you
shouldn’t do this anyway, because it will perform quite poorly most
of the time!)  Use &lt;code&gt;wsgi.file_wrapper&lt;/code&gt; or an application-specific
file wrapper class.  (See &lt;code&gt;Optional Platform-Specific File Handling&lt;/code&gt;_
for more on &lt;code&gt;wsgi.file_wrapper&lt;/code&gt;, and an example class you can use
to wrap a file as an iterable.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If you return a custom iterable, it &lt;strong&gt;must&lt;/strong&gt; implement the pre-2.2
iterator protocol.  That is, provide a &lt;code&gt;__getitem__&lt;/code&gt; method that
accepts an integer key, and raises &lt;code&gt;IndexError&lt;/code&gt; when exhausted.
(Note that built-in sequence types are also acceptable, since they
also implement this protocol.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, middleware that wishes to support pre-2.2 versions of Python,
and iterates over application return values or itself returns an
iterable (or both), must follow the appropriate recommendations above.&lt;/p&gt;

&lt;p&gt;(Note: It should go without saying that to support pre-2.2 versions
of Python, any server, gateway, application, or middleware must also
use only language features available in the target version, use
1 and 0 instead of &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;, etc.)&lt;/p&gt;

&lt;h2 id=&quot;optional-platform-specific-file-handling&quot;&gt;Optional Platform-Specific File Handling&lt;/h2&gt;

&lt;p&gt;Some operating environments provide special high-performance file-
transmission facilities, such as the Unix &lt;code&gt;sendfile()&lt;/code&gt; call.
Servers and gateways &lt;strong&gt;may&lt;/strong&gt; expose this functionality via an optional
&lt;code&gt;wsgi.file_wrapper&lt;/code&gt; key in the &lt;code&gt;environ&lt;/code&gt;.  An application
&lt;strong&gt;may&lt;/strong&gt; use this “file wrapper” to convert a file or file-like object
into an iterable that it then returns, e.g.::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if &#39;wsgi.file_wrapper&#39; in environ:
    return environ[&#39;wsgi.file_wrapper&#39;](filelike, block_size)
else:
    return iter(lambda: filelike.read(block_size), &#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the server or gateway supplies &lt;code&gt;wsgi.file_wrapper&lt;/code&gt;, it must be
a callable that accepts one required positional parameter, and one
optional positional parameter.  The first parameter is the file-like
object to be sent, and the second parameter is an optional block
size “suggestion” (which the server/gateway need not use).  The
callable &lt;strong&gt;must&lt;/strong&gt; return an iterable object, and &lt;strong&gt;must not&lt;/strong&gt; perform
any data transmission until and unless the server/gateway actually
receives the iterable as a return value from the application.
(To do otherwise would prevent middleware from being able to interpret
or override the response data.)&lt;/p&gt;

&lt;p&gt;To be considered “file-like”, the object supplied by the application
must have a &lt;code&gt;read()&lt;/code&gt; method that takes an optional size argument.
It &lt;strong&gt;may&lt;/strong&gt; have a &lt;code&gt;close()&lt;/code&gt; method, and if so, the iterable returned
by &lt;code&gt;wsgi.file_wrapper&lt;/code&gt; &lt;strong&gt;must&lt;/strong&gt; have a &lt;code&gt;close()&lt;/code&gt; method that
invokes the original file-like object’s &lt;code&gt;close()&lt;/code&gt; method.  If the
“file-like” object has any other methods or attributes with names
matching those of Python built-in file objects (e.g. &lt;code&gt;fileno()&lt;/code&gt;),
the &lt;code&gt;wsgi.file_wrapper&lt;/code&gt; &lt;strong&gt;may&lt;/strong&gt; assume that these methods or
attributes have the same semantics as those of a built-in file object.&lt;/p&gt;

&lt;p&gt;The actual implementation of any platform-specific file handling
must occur &lt;strong&gt;after&lt;/strong&gt; the application returns, and the server or
gateway checks to see if a wrapper object was returned.  (Again,
because of the presence of middleware, error handlers, and the like,
it is not guaranteed that any wrapper created will actually be used.)&lt;/p&gt;

&lt;p&gt;Apart from the handling of &lt;code&gt;close()&lt;/code&gt;, the semantics of returning a
file wrapper from the application should be the same as if the
application had returned &lt;code&gt;iter(filelike.read, &#39;&#39;)&lt;/code&gt;.  In other words,
transmission should begin at the current position within the “file”
at the time that transmission begins, and continue until the end is
reached.&lt;/p&gt;

&lt;p&gt;Of course, platform-specific file transmission APIs don’t usually
accept arbitrary “file-like” objects.  Therefore, a
&lt;code&gt;wsgi.file_wrapper&lt;/code&gt; has to introspect the supplied object for
things such as a &lt;code&gt;fileno()&lt;/code&gt; (Unix-like OSes) or a
&lt;code&gt;java.nio.FileChannel&lt;/code&gt; (under Jython) in order to determine if
the file-like object is suitable for use with the platform-specific
API it supports.&lt;/p&gt;

&lt;p&gt;Note that even if the object is &lt;em&gt;not&lt;/em&gt; suitable for the platform API,
the &lt;code&gt;wsgi.file_wrapper&lt;/code&gt; &lt;strong&gt;must&lt;/strong&gt; still return an iterable that wraps
&lt;code&gt;read()&lt;/code&gt; and &lt;code&gt;close()&lt;/code&gt;, so that applications using file wrappers
are portable across platforms.  Here’s a simple platform-agnostic
file wrapper class, suitable for old (pre 2.2) and new Pythons alike::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class FileWrapper:

    def __init__(self, filelike, blksize=8192):
        self.filelike = filelike
        self.blksize = blksize
        if hasattr(filelike, &#39;close&#39;):
            self.close = filelike.close

    def __getitem__(self, key):
        data = self.filelike.read(self.blksize)
        if data:
            return data
        raise IndexError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and here is a snippet from a server/gateway that uses it to provide
access to a platform-specific API::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;environ[&#39;wsgi.file_wrapper&#39;] = FileWrapper
result = application(environ, start_response)

try:
    if isinstance(result, FileWrapper):
        # check if result.filelike is usable w/platform-specific
        # API, and if so, use that API to transmit the result.
        # If not, fall through to normal iterable handling
        # loop below.

    for data in result:
        # etc.

finally:
    if hasattr(result, &#39;close&#39;):
        result.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;questions-and-answers&quot;&gt;Questions and Answers&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Why must &lt;code&gt;environ&lt;/code&gt; be a dictionary?  What’s wrong with using a
subclass?&lt;/p&gt;

    &lt;p&gt;The rationale for requiring a dictionary is to maximize portability
between servers.  The alternative would be to define some subset of
a dictionary’s methods as being the standard and portable
interface.  In practice, however, most servers will probably find a
dictionary adequate to their needs, and thus framework authors will
come to expect the full set of dictionary features to be available,
since they will be there more often than not.  But, if some server
chooses &lt;em&gt;not&lt;/em&gt; to use a dictionary, then there will be
interoperability problems despite that server’s “conformance” to
spec.  Therefore, making a dictionary mandatory simplifies the
specification and guarantees interoperability.&lt;/p&gt;

    &lt;p&gt;Note that this does not prevent server or framework developers from
offering specialized services as custom variables &lt;em&gt;inside&lt;/em&gt; the
&lt;code&gt;environ&lt;/code&gt; dictionary.  This is the recommended approach for
offering any such value-added services.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Why can you call &lt;code&gt;write()&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; yield strings/return an
iterable?  Shouldn’t we pick just one way?&lt;/p&gt;

    &lt;p&gt;If we supported only the iteration approach, then current
frameworks that assume the availability of “push” suffer.  But, if
we only support pushing via &lt;code&gt;write()&lt;/code&gt;, then server performance
suffers for transmission of e.g. large files (if a worker thread
can’t begin work on a new request until all of the output has been
sent).  Thus, this compromise allows an application framework to
support both approaches, as appropriate, but with only a little
more burden to the server implementor than a push-only approach
would require.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s the &lt;code&gt;close()&lt;/code&gt; for?&lt;/p&gt;

    &lt;p&gt;When writes are done during the execution of an application
object, the application can ensure that resources are released
using a try/finally block.  But, if the application returns an
iterable, any resources used will not be released until the
iterable is garbage collected.  The &lt;code&gt;close()&lt;/code&gt; idiom allows an
application to release critical resources at the end of a request,
and it’s forward-compatible with the support for try/finally in
generators that’s proposed by PEP 325.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Why is this interface so low-level?  I want feature X!  (e.g.
cookies, sessions, persistence, …)&lt;/p&gt;

    &lt;p&gt;This isn’t Yet Another Python Web Framework.  It’s just a way for
frameworks to talk to web servers, and vice versa.  If you want
these features, you need to pick a web framework that provides the
features you want.  And if that framework lets you create a WSGI
application, you should be able to run it in most WSGI-supporting
servers.  Also, some WSGI servers may offer additional services via
objects provided in their &lt;code&gt;environ&lt;/code&gt; dictionary; see the
applicable server documentation for details.  (Of course,
applications that use such extensions will not be portable to other
WSGI-based servers.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Why use CGI variables instead of good old HTTP headers?  And why
mix them in with WSGI-defined variables?&lt;/p&gt;

    &lt;p&gt;Many existing web frameworks are built heavily upon the CGI spec,
and existing web servers know how to generate CGI variables.  In
contrast, alternative ways of representing inbound HTTP information
are fragmented and lack market share.  Thus, using the CGI
“standard” seems like a good way to leverage existing
implementations.  As for mixing them with WSGI variables,
separating them would just require two dictionary arguments to be
passed around, while providing no real benefits.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What about the status string?  Can’t we just use the number,
passing in &lt;code&gt;200&lt;/code&gt; instead of &lt;code&gt;&quot;200 OK&quot;&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;Doing this would complicate the server or gateway, by requiring
them to have a table of numeric statuses and corresponding
messages.  By contrast, it is easy for an application or framework
author to type the extra text to go with the specific response code
they are using, and existing frameworks often already have a table
containing the needed messages.  So, on balance it seems better to
make the application/framework responsible, rather than the server
or gateway.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Why is &lt;code&gt;wsgi.run_once&lt;/code&gt; not guaranteed to run the app only once?&lt;/p&gt;

    &lt;p&gt;Because it’s merely a suggestion to the application that it should
“rig for infrequent running”.  This is intended for application
frameworks that have multiple modes of operation for caching,
sessions, and so forth.  In a “multiple run” mode, such frameworks
may preload caches, and may not write e.g. logs or session data to
disk after each request.  In “single run” mode, such frameworks
avoid preloading and flush all necessary writes after each request.&lt;/p&gt;

    &lt;p&gt;However, in order to test an application or framework to verify
correct operation in the latter mode, it may be necessary (or at
least expedient) to invoke it more than once.  Therefore, an
application should not assume that it will definitely not be run
again, just because it is called with &lt;code&gt;wsgi.run_once&lt;/code&gt; set to
&lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Feature X (dictionaries, callables, etc.) are ugly for use in
application code; why don’t we use objects instead?&lt;/p&gt;

    &lt;p&gt;All of these implementation choices of WSGI are specifically
intended to &lt;em&gt;decouple&lt;/em&gt; features from one another; recombining these
features into encapsulated objects makes it somewhat harder to
write servers or gateways, and an order of magnitude harder to
write middleware that replaces or modifies only small portions of
the overall functionality.&lt;/p&gt;

    &lt;p&gt;In essence, middleware wants to have a “Chain of Responsibility”
pattern, whereby it can act as a “handler” for some functions,
while allowing others to remain unchanged.  This is difficult to do
with ordinary Python objects, if the interface is to remain
extensible.  For example, one must use &lt;code&gt;__getattr__&lt;/code&gt; or
&lt;code&gt;__getattribute__&lt;/code&gt; overrides, to ensure that extensions (such as
attributes defined by future WSGI versions) are passed through.&lt;/p&gt;

    &lt;p&gt;This type of code is notoriously difficult to get 100% correct, and
few people will want to write it themselves.  They will therefore
copy other people’s implementations, but fail to update them when
the person they copied from corrects yet another corner case.&lt;/p&gt;

    &lt;p&gt;Further, this necessary boilerplate would be pure excise, a
developer tax paid by middleware developers to support a slightly
prettier API for application framework developers.  But,
application framework developers will typically only be updating
&lt;em&gt;one&lt;/em&gt; framework to support WSGI, and in a very limited part of
their framework as a whole.  It will likely be their first (and
maybe their only) WSGI implementation, and thus they will likely
implement with this specification ready to hand.  Thus, the effort
of making the API “prettier” with object attributes and suchlike
would likely be wasted for this audience.&lt;/p&gt;

    &lt;p&gt;We encourage those who want a prettier (or otherwise improved) WSGI
interface for use in direct web application programming (as opposed
to web framework development) to develop APIs or frameworks that
wrap WSGI for convenient use by application developers.  In this
way, WSGI can remain conveniently low-level for server and
middleware authors, while not being “ugly” for application
developers.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;proposedunder-discussion&quot;&gt;Proposed/Under Discussion&lt;/h1&gt;

&lt;p&gt;These items are currently being discussed on the Web-SIG and elsewhere,
or are on the PEP author’s “to-do” list:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Should &lt;code&gt;wsgi.input&lt;/code&gt; be an iterator instead of a file?  This would
help for asynchronous applications and chunked-encoding input
streams.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Optional extensions are being discussed for pausing iteration of an
application’s output until input is available or until a callback
occurs.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Add a section about synchronous vs. asynchronous apps and servers,
the relevant threading models, and issues/design goals in these
areas.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;/h1&gt;

&lt;p&gt;Thanks go to the many folks on the Web-SIG mailing list whose
thoughtful feedback made this revised draft possible.  Especially:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Gregory “Grisha” Trubetskoy, author of &lt;code&gt;mod_python&lt;/code&gt;, who beat up
on the first draft as not offering any advantages over “plain old
CGI”, thus encouraging me to look for a better approach.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ian Bicking, who helped nag me into properly specifying the
multithreading and multiprocess options, as well as badgering me to
provide a mechanism for servers to supply custom extension data to
an application.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tony Lownds, who came up with the concept of a &lt;code&gt;start_response&lt;/code&gt;
function that took the status and headers, returning a &lt;code&gt;write&lt;/code&gt;
function.  His input also guided the design of the exception handling
facilities, especially in the area of allowing for middleware that
overrides application error messages.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Alan Kennedy, whose courageous attempts to implement WSGI-on-Jython
(well before the spec was finalized) helped to shape the “supporting
older versions of Python” section, as well as the optional
&lt;code&gt;wsgi.file_wrapper&lt;/code&gt; facility.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mark Nottingham, who reviewed the spec extensively for issues with
HTTP RFC compliance, especially with regard to HTTP/1.1 features that
I didn’t even know existed until he pointed them out.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;

&lt;p&gt;.. [1] The Python Wiki “Web Programming” topic
   (http://www.python.org/cgi-bin/moinmoin/WebProgramming)&lt;/p&gt;

&lt;p&gt;.. [2] The Common Gateway Interface Specification, v 1.1, 3rd Draft
   (http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt)&lt;/p&gt;

&lt;p&gt;.. [3] “Chunked Transfer Coding” – HTTP/1.1, section 3.6.1
   (http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1)&lt;/p&gt;

&lt;p&gt;.. [4] “End-to-end and Hop-by-hop Headers” – HTTP/1.1, Section 13.5.1
   (http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.5.1)&lt;/p&gt;

&lt;p&gt;.. [5] mod_ssl Reference, “Environment Variables”
   (http://www.modssl.org/docs/2.8/ssl_reference.html#ToC25)&lt;/p&gt;

&lt;h1 id=&quot;copyright&quot;&gt;Copyright&lt;/h1&gt;

&lt;p&gt;This document has been placed in the public domain.&lt;/p&gt;

&lt;p&gt;..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Dec 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/12/28/wsgi.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/12/28/wsgi.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Excel到底有多厉害之用Excel画系统架构图</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;对Excel一直非常感兴趣，excel到底有多厉害，请看我用excel画的一个系统架构图，关键敏感信息已经进行了模糊处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/image/excelJia.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 22 Dec 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/java/2016/12/22/exceljia.html</link>
        <guid isPermaLink="true">http://colorful.ren/java/2016/12/22/exceljia.html</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>nginx+uwsgi+python+mysql+flask 实战过程</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;使用python进行web开发，环境的搭建并不简单，这里面出现了很多问题。记录一下自己搭建环境的过程，顺便记录一下自己对于用python进行web开发的原理的一点粗浅的理解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;nginxuwsgipython&quot;&gt;nginx,uwsgi,python工作的原理&lt;/h3&gt;

&lt;p&gt;如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/python8.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上是python进行web开发的基本工作原理，当然了，也可以不用使用uwsgi,但是使用uwsgi才是主流，非主流的这里就不记录了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户发起http请求，请求到达nginx服务器。&lt;/li&gt;
  &lt;li&gt;nginx根据请求的url和自己的配置来决定怎么处理&lt;/li&gt;
  &lt;li&gt;一般如果是静态请求，直接索引文件系统返回静态资源&lt;/li&gt;
  &lt;li&gt;如果是动态请求，则交给后面的uwsgi来处理&lt;/li&gt;
  &lt;li&gt;uwsgi进程接到请求后，启动python解释器来执行python程序。&lt;/li&gt;
  &lt;li&gt;执行解释返回结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上是大体的过程，用词可能不够准确。这个过程中有一个核心概念：&lt;code&gt;uwsgi&lt;/code&gt;，如果要把这个说清楚，会牵扯出一些列的知识：CGI,FAST-CGI,WSGI。这个之前有记录。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;参考文档&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html&quot;&gt;uwsgi官方文档英文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/WSGIquickstart.html&quot;&gt;uwsgi官方文档中文&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;原生环境搭建过程&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;首先不使用任何python框架搭建一个原生的python web环境&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我这里有一台虚拟机:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;192.168.116.131
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我将nginx和uwsgi都安装在131上，这里nginx我之前已经安装过了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;安装uwsgi，安装到&lt;code&gt;/application/uwsgi-2.0.14&lt;/code&gt;这个目录&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; wget https://projects.unbit.it/downloads/uwsgi-latest.tar.gz
 tar zxvf uwsgi-latest.tar.gz -C /application/uwsgi-2.0.14
 cd /application/uwsgi-2.0.14
 make
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将uwsgi添加进环境变量搜索路径中&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; cp /application/uwsgi-2.0.14/uwsgi /usr/local/sbin/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;建立一个软链接,这是一个好习惯&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; ln -s /application/uwsgi-2.0.14 /application/uwsgi
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编写python脚本，这里假设mysql已经部署好了&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; cd /home/fulin/temp/
 vi app.py
	
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
	
 &quot;&quot;&quot;application.py&quot;&quot;&quot;
	
 import MySQLdb
 def application(environ, start_response):
 &quot;&quot;&quot;Simplest possible application object&quot;&quot;&quot;
 start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;,&#39;text/html&#39;)])
 conn = MySQLdb.connect(host = &#39;10.2xx.xx.62&#39;,\
                        port = 3306,\
                        user = &#39;xx&#39;,\
                        passwd = &#39;xxx&#39;,\
                        db = &#39;test&#39;)
 cur = conn.cursor()
	
 aa =cur.execute(&quot;select * from vc_admin limit 10&quot;)
 x = []
 info = cur.fetchmany(aa)
 for i in info:
     x.append(i)
 cur.close()
 conn.commit()
 conn.close()
 return &#39;.&#39;.join([str(i) for i in x])
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动uwsgi&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; uwsgi --socket 127.0.0.1:3031 --wsgi-file /home/fulin/temp/app.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置nginx，因为这里仅仅是学习，所以不必用配置太复杂，先从最简单的开始&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; location / {
    include uwsgi_params;
    uwsgi_pass 192.168.116.132:3031;
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动nginx&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; cd /application/nginx/sbin
 ./nginx
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  浏览器输入  http://192.168.116.131
  响应出admin表中的数据，表示OK
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;uwsgiflask&quot;&gt;uwsgi和flask进行集成&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;这里web服务器和应用服务器选择使用socket通信,不再使用低效的http&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;启用&lt;code&gt;ini&lt;/code&gt;配置文件,文件为&lt;code&gt;/home/fulin/temp/web/config.ini&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [uwsgi]
 socket = /tmp/my.sock     	#和web服务器通信的socket文件
 chmod-socket = 666		  	#更改socket文件的权限为666
 daemonize = /home/fulin/temp/flask2.log  #将uwsgi以守护进程的方式启动，同时制定日志文件
 master = true				#是否为主进程
 pidfile = /home/fulin/temp/master.pid   #创建主进程的pid文件
 wsgi-file = app.py	  #web项目的入口
 callable = app			#入口对象
 processes =1    		#进程数
 threads = 1				#线程数
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意这里的ini配置文件出现是有背景的，之前我们启动uwsgi是使用命令行的方式：uwsgi –socket 127.0.0.1:3031 –wsgi-file /home/fulin/temp/app.py –master –processes 4 –threads 2 –stats 127.0.0.1:9191，这种方式非常的不人性，如果能把命令行中的参数写入配置文件就好了。uwsgi是支持的。最标准的方法是使用ini格式的配置文件,我们的配置文件名为config.ini&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;这里要特别提醒一下,config.ini文件的开头的&lt;code&gt;[uwsgi]&lt;/code&gt;这几个字符是不能少的，我就是因为没有这几个字符，启动的时候出现了一个很诡异的异常而浪费了很长时间&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;准备flask项目文件&lt;code&gt;/home/fulin/temp/web/app.py&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; from flask import Flask

 app = Flask(__name__)
	
 @app.route(&#39;/&#39;)
 def index():
     return &#39;&amp;lt;h1&amp;gt;hello world&amp;lt;/h1&amp;gt;&#39;
	
 @app.route(&#39;/&amp;lt;name&amp;gt;&#39;)
 def user(name):
     return &#39;&amp;lt;h1&amp;gt;hello, %s&amp;lt;/h1&amp;gt;&#39; % name
	
 #if __name__ == __name__:
 #    app.run(debug=True)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;这里要注意：&lt;code&gt;__name__==__name__&lt;/code&gt;那两句代码是被注释掉的。因为uwsgi启动的时候会运行app.py，这段代码不注释掉，会启动python自己的 wsgi 服务器，从而产生冲突。也只有和uwsgi配合使用的时候才需要注释，开发的时候，还需要用这个功能才测试。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;uwsgi的启动&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; uwsgi --ini /home/fulin/temp/web/config.ini
 输出：
 [uWSGI] getting INI configuration from /home/fulin/temp/web/config.ini
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nginx的配置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; location / {
    include uwsgi_params;
    uwsgi_pass unix:/tmp/my.sock;
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;这里要注意&lt;code&gt;uwsgi_pass unix:/tmp/my.sock;&lt;/code&gt;,/tmp/my.sock这个文件，nginx进程需要有读写和执行权限才行，这个套接字文件是nginx和uwsgi进行通信的纽带&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;启动nginx&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; cd /application/nginx/sbin
 nginx
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 浏览器输入  http://192.168.116.131
 响应出hello world，表示OK
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;这两个环境的搭建，虽然逻辑比较简单，但是还是花了我两天的时候，我自己反思了一下，为什么会这么久，主要是有两方面的原因：一方面是之前确实没有接触过&lt;code&gt;uwsgi&lt;/code&gt;,所以需要摸索一下，另一方面出现问题之后，没有认真看官方文档，很多细节，官方文档中都有详细的描述。如果认真阅读会事半功倍的。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sat, 26 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/26/uwsgi-python.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/26/uwsgi-python.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>python基础知识点之常用数据库API</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#db-api&quot; id=&quot;markdown-toc-db-api&quot;&gt;DB-API简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#db-api-1&quot; id=&quot;markdown-toc-db-api-1&quot;&gt;DB-API详解&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;模块接口&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#connection&quot; id=&quot;markdown-toc-connection&quot;&gt;数据库连接对象(connection)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cursor&quot; id=&quot;markdown-toc-cursor&quot;&gt;游标对象（cursor）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#sqlite3&quot; id=&quot;markdown-toc-sqlite3&quot;&gt;sqlite3连接实例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mysql&quot; id=&quot;markdown-toc-mysql&quot;&gt;mysql连接实例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;记录一下学习python的过程中与数据库有关的知识点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;db-api&quot;&gt;DB-API简介&lt;/h2&gt;

&lt;p&gt;一个处理 Python 数据库事务的特殊兴趣小组（SIG，special interest group）为了统一python访问数据库的接口，制定了一个规范&lt;code&gt;DB-API&lt;/code&gt;,这套规范定义了一系列必须的对象和数据库存取方式, 以便为各种各样的底层数据库系统和多种多样的数据库接口程序提供一致的访问接口&lt;/p&gt;

&lt;p&gt;通过DB-API规范访问数据库的流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/python7.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;db-api-1&quot;&gt;DB-API详解&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;DB-API对以下几个方面做了规范&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;模块接口&lt;/li&gt;
  &lt;li&gt;数据库连接对象&lt;/li&gt;
  &lt;li&gt;游标对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;模块接口&lt;/h3&gt;

&lt;p&gt;数据库的访问是通过连接对象（connection objects）来实现的。程序模块中必须提供以下形式的连接对象构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;connect(parameters...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据库连接对象的构造函数，返回值为Connection对象实例。 由于目的数据库不同，函数接收数量不等的一些参数。&lt;/p&gt;

&lt;p&gt;模块中必须定义下面这些模块级的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apilevel
	字符串常量，表明支持的DB API版本。
	目前只允许取值&#39;1.0&#39;和&#39;2.0&#39;。
	如果没有定义本常量，默认为DB-API 1.0DB-API

threadsafety	
	整数常量，表明模块支持的线程安全级别，可能的值为：

	0     线程不安全，线程不能共享模块。
	1     线程可以共享模块，但是不能共享连接对象（connections）。
	2     线程可以共享模块和连接对象。
	3     线程安全，线程间可以共享模块、连接对象以及游标对象
	
	上文中共享的意思是两个线程在没有使用互斥信号
	（mutex semaphore）锁的情况下， 同时使用一个资源。

	要注意的是，你并不总能使用互斥信号来确保一个外部资源线程安全，
	这是因为外部资源很有可能依赖于一个全局变量或是其他的外部资源，
	然而这些是你不能控制的

paramstyle		
	字符串常量声明模块使用的SQL语句中的参数引出方式。可能的取值如下

	&#39;qmark&#39;         问号方式，例如：&#39;...WHERE name=?&#39;
	&#39;numeric&#39;       序数方式，例如：&#39;...WHERE name=:1&#39;
	&#39;named&#39;         命名方式，例如：&#39;...WHERE name=:name&#39;
	&#39;format&#39;        通用方式例如：&#39;...WHERE name=%s&#39;
	&#39;pyformat&#39;      python扩展方式例如：&#39;...WHERE name=%(name)s&#39;

Warning 
	当有严重警告时触发，例如插入数据是被截断等等。
	必须是Python StandardError的子类（定义于exceptions模块中）。

Error
	这应该是警告以外所有其他错误类的基类。你可以使用这个类在单一
	的‘except’语句中捕捉所有的错误。警告（Warnings）不应认为是错误，
	因此不应该以此类作为基类，而只应该以Python StandardError作为基类。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;connection&quot;&gt;数据库连接对象(connection)&lt;/h3&gt;

&lt;p&gt;连接对象应该具有下面的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;close()
	马上关闭数据连接（而不是当__del__方法被调用的时候）。

	连接应该此后变得不可用，再次访问本连接对象应该触发
	一个错误（Error或其子类），同样所有使用本连接对象的游标（cursor）
	对象，也会导致例外发生。

	需要注意的是，在关闭连接对象之前，没有首先提交对数据库的改变
	将会导致一个隐含的回滚动作（rollback），这将丢弃之前的数据改变操作

commit()
	提交任何挂起的事务到数据库中。

	需要注意的是，如果数据库支持自动提交（auto-commit），必须
	在初始化时关闭。一般会有一个接口函数关闭此特性。

	不支持事务的数据库也应该实现此方法，只需什么都不做。

rollback()
	由于并非所有数据库都支持事务，此方法是可选的.

	对于支持事务的数据库，调用此方法将导致数据库回滚到事务
	开始时的状态。关闭数据库连接之前没有明确调用commit()提交
	数据更新，将隐含导致rollback()被执行。

cursor()
	方法返回给定连接上建立的游标对象（Cursor Object）。如果数据库
	没有提供对应的游标对象，那么将由程序来模拟实现游标功能
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;cursor&quot;&gt;游标对象（cursor）&lt;/h3&gt;

&lt;p&gt;游标对象表示数据库游标，游标用来管理获取结果操作的上下文对象。同一个连接对象创建的游标对象不是彼此隔离的，也就是说一个游标对象对数据库造成的变化将会对于其他游标对象立即可见。而不同的连接对象创建的游标，则可能是隔离的也可能是非隔离的，这取决于数据库对事务的支持的实现（参见连接对象的.rollback()和.commit()方法）。&lt;/p&gt;

&lt;p&gt;游标对象应具有以下的方法和属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;description 
	这是一个只读属性，是7个项目组成的tulip的序列。
	每个tulip包含描述一个结果集中的列的信息描述：

	(
		name, 
		type_code, 
		display_size,
		internal_size, 
		precision, 
		scale, 
		null_ok
	)
	
	其中，前两个项目(name and type_code)时必须的，其他的五项是可选的。
	如果没有意义可以设置为None。

	对于没有返回结果集的操作或者游标对象还没有执行过任何.execute*()的操作
	本属性可以为空（None）。

	type_code的含义可以比对下面Type对象的描述。

rowcount 
	这是一个只读属性
	
	描述的是最后一次数据库操作影响的数据行数
	（执行.execute系列方法）。 可以是数据查询语句（DQL），
	比如&#39;select&#39;等返回的数据行，也可以是数据操纵语句（DML ）
	比如&#39;update&#39; 和&#39;insert&#39;语句等所影响的数据行。

	如果还没有执行过任何语句，或者操作本身影响的函数由于数据访问接口的原因不能检测到。则本属性的值为-1
	
	注：将来的版本有可能重新定义后一种情况，使其取值为空（None）而不是-1。
        
callproc(procname[,parameters])
	(由于并非每种数据库都支持存储过程，此方法是可选的)

	调用数据库存储过程时，首先必须给出存储过程的名字，
	其次，对于存储过程需要的每一个参数都必须依次给出。

	调用结果按照调用时的次序，输入型参数（Input parameters）
	原样不动，输出型和输入输出二合一型参数可能会被新的内容代替。
	存储过程也很可能以数据结果集作为返回结果，

	此时就要用标准的fech系列方法来获取结果了（.fetch*() methods）。

close()
	立即关闭游标（不论 __del__方法是否已调用）。

	从此刻开始游标对象就变得不可用了。
	任何试图访问此游标对象的方法或属性的动作都将导致一个错误Error或其子类被抛出。

execute(operation[,parameters]) 
	准备和执行数据库操作（查询或其他命令）。
	所提供参数将会被绑定到语句中的变量。变量的定义和数据库模块有关。
	（请参见模块的paramstyle属性的描述）。
	
	游标对象将会保留这个操作的引用，如果一个后续的相同的操作被调用，
	游标对象将会以此来进行优化。当有相同的操作调用（不同的参数变量被传递）
	时，这是最为有效的优化。
	
	一项数据库操作，为了获得最大的执行效率，最好先期使用方法.setinputsizes() 来
	指定参数的类型和大小。执行时实际给出的参数和预定义的不同也是合法的，模块的实现
	需要容忍这个问题，即使以效率的损失为代价。
	
	参数可以以tuples的tuple或list的形式提供，例如当在一次调用中插入多行数据。但是
	这种调用应被认为是抛弃的不建议使用，应该使用专用的方法.executemany() 。
	
	没有对返回值进行明确界定。

executemany(operation,seq_of_parameters) 
	准备数据库操作（查询或其他命令），然后以序列的序列形式的函数
	来执行该操作。
	
	模块开发这可以自由选择是转化为一系列的.execute() 方法调用，还是以
	数组操作的形式，以便使数据库把这个序列的操作作为一个整体。
	
	使用此方法，可能产生一个或多个由未知的行为构成的结果集。
	建议模块作者（而不是要求）当检测到一次调用已经产生结果集时抛出例外。
	
	对于.execute()方法的描述同样可适于此方法。
	
	返回值未定义。

fetchone()
	从一查询结果集中获取下一行数据，返回值为一个值的序列，如果没有更多数据
	了则返回None。
	
	如果上次的.execute系列方法的调用没有生成任何结果集()或还没有进行任何数据
	库操作的调用，则调用此方法将抛出例外（Error或其子类）。

.fetchmany([size=cursor.arraysize])
      
	Fetch the next set of rows of a query result, returning a
	sequence of sequences (e.g. a list of tuples). An empty
	sequence is returned when no more rows are available.
	
	The number of rows to fetch per call is specified by the
	parameter.  If it is not given, the cursor&#39;s arraysize
	determines the number of rows to be fetched. The method
	should try to fetch as many rows as indicated by the size
	parameter. If this is not possible due to the specified
	number of rows not being available, fewer rows may be
	returned.
	
	An Error (or subclass) exception is raised if the previous
	call to .execute*() did not produce any result set or no
	call was issued yet.
	
	Note there are performance considerations involved with
	the size parameter.  For optimal performance, it is
	usually best to use the arraysize attribute.  If the size
	parameter is used, then it is best for it to retain the
	same value from one .fetchmany() call to the next.
        
fetchall() 

	Fetch all (remaining) rows of a query result, returning
	them as a sequence of sequences (e.g. a list of tuples).
	Note that the cursor&#39;s arraysize attribute can affect the
	performance of this operation.
	
	An Error (or subclass) exception is raised if the previous
	call to .execute*() did not produce any result set or no
	call was issued yet.
        
nextset() 
      
	(This method is optional since not all databases support
	multiple result sets. [3])
	
	This method will make the cursor skip to the next
	available set, discarding any remaining rows from the
	current set.
	
	If there are no more sets, the method returns
	None. Otherwise, it returns a true value and subsequent
	calls to the fetch methods will return rows from the next
	result set.
	
	An Error (or subclass) exception is raised if the previous
	call to .execute*() did not produce any result set or no
	call was issued yet.

arraysize
      
	This read/write attribute specifies the number of rows to
	fetch at a time with .fetchmany(). It defaults to 1
	meaning to fetch a single row at a time.
	
	Implementations must observe this value with respect to
	the .fetchmany() method, but are free to interact with the
	database a single row at a time. It may also be used in
	the implementation of .executemany().
        
setinputsizes(sizes)
      
	This can be used before a call to .execute*() to
	predefine memory areas for the operation&#39;s parameters.
	
	sizes is specified as a sequence -- one item for each
	input parameter.  The item should be a Type Object that
	corresponds to the input that will be used, or it should
	be an integer specifying the maximum length of a string
	parameter.  If the item is None, then no predefined memory
	area will be reserved for that column (this is useful to
	avoid predefined areas for large inputs).
	
	This method would be used before the .execute*() method
	is invoked.
	
	Implementations are free to have this method do nothing
	and users are free to not use it.
        
setoutputsize(size[,column])
      
	Set a column buffer size for fetches of large columns
	(e.g. LONGs, BLOBs, etc.).  The column is specified as an
	index into the result sequence.  Not specifying the column
	will set the default size for all large columns in the
	cursor.
	
	This method would be used before the .execute*() method
	is invoked.
	
	Implementations are free to have this method do nothing
	and users are free to not use it.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;sqlite3&quot;&gt;sqlite3连接实例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import sqlite3
&amp;gt;&amp;gt;&amp;gt; conn = sqlite3.connect(r&#39;D:\test.db&#39;)
&amp;gt;&amp;gt;&amp;gt; cursor = conn.cursor()
&amp;gt;&amp;gt;&amp;gt; cursor.execute(&#39;create table user (id varchar(20) primary key,name varchar(20))&#39;)
&amp;lt;sqlite3.Cursor object at 0x03119BE0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; cursor.execute(&#39;insert into user (id,name) values(\&#39;1\&#39;,\&#39;Michael\&#39;)&#39;)
&amp;lt;sqlite3.Cursor object at 0x03119BE0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; cursor.rowcount
1
&amp;gt;&amp;gt;&amp;gt; cursor.close()
&amp;gt;&amp;gt;&amp;gt; conn.commit()
&amp;gt;&amp;gt;&amp;gt; conn.close()

&amp;gt;&amp;gt;&amp;gt; conn = sqlite3.connect(r&#39;D:\test.db&#39;)
&amp;gt;&amp;gt;&amp;gt; curo = conn.cursor()
&amp;gt;&amp;gt;&amp;gt; curo.execute(&#39;select * from user&#39;)
&amp;lt;sqlite3.Cursor object at 0x03119C20&amp;gt;
&amp;gt;&amp;gt;&amp;gt; info = curo.fetchall()
&amp;gt;&amp;gt;&amp;gt; info
[(u&#39;1&#39;, u&#39;Michael&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mysql&quot;&gt;mysql连接实例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import MySQLdb
&amp;gt;&amp;gt;&amp;gt; conn = MySQLdb.connect(host = &#39;xx.xxx.xx.xx&#39;,\
                   port = 3306,\
                   user = &#39;xxx&#39;,\
                   passwd = &#39;xxxx&#39;,\
                   db = &#39;xxx&#39;)
&amp;gt;&amp;gt;&amp;gt; cur = conn.cursor()
&amp;gt;&amp;gt;&amp;gt; cur.execute(&#39;select * from vc_admin limit 10&#39;)
&amp;gt;&amp;gt;&amp;gt; info = cur.fetchall()
&amp;gt;&amp;gt;&amp;gt; for i in info:
		print i[0],i[1]

1 admin
8271 255137
8273 YH001
8275 YH004
8277 YH002
8279 YH003
8281 255130
8283 255138
8285 255139
8287 255140
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 24 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/24/python7.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/24/python7.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>python基础知识点之常用标准模块</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#random-&quot; id=&quot;markdown-toc-random-&quot;&gt;random 模块（随机数模块）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#shelve-&quot; id=&quot;markdown-toc-shelve-&quot;&gt;shelve 模块&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#re-&quot; id=&quot;markdown-toc-re-&quot;&gt;re 模块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;python中的标准模块有很多实用的功能，将常用的操作进行了封装，掌握了常用的标准模块的功能可以大幅度的提高工作效率&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;random-&quot;&gt;random 模块（随机数模块）&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;import random
random.random()		
	#返回0到1之间的小数
random.getrandbits(16)
	#返回16位的整数，这里的位是二进制的位。
random.uniform(1.2,5.7)
	#返回1.2到5.7之间的随机实数
random.randrange(1,8,2)
	#返回1到8之间步长为2的随机数
random.choice([1,2,3,4,5])
	#随机的返回序列中的一个元素
random.shuffles(s)
	#将列表s的元素随机的混乱处理，处理之后，s中的元素位置就变了
random.sample(s,n)
	#随机的返回序列s中的n个元素，返回类型是列表
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;shelve-&quot;&gt;shelve 模块&lt;/h2&gt;

&lt;p&gt;shelve 模块使用数据库驱动实现了字典对象的持久保存. shelve 对象使用字符串作为键, 但值可以是任意类型,我们简单的理解为shelve对象就是一个字典。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import shelve
db = shelve.open(&#39;D://dbdata.db&#39;)
db[&#39;person&#39;]=range(100)
db.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用shelve比较简单，但是要注意，最后一定要调用其close()方法。&lt;/p&gt;

&lt;h2 id=&quot;re-&quot;&gt;re 模块&lt;/h2&gt;

&lt;p&gt;re 模块提供了一系列功能强大的正则表达式工具, 它允许你快速检查给定字符串是否与给定的模式匹配 (使用 match 函数), 或者包含这个模式 (使用 search 函数)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compile(): 创建模式对象
search():  从字符串中根据模式搜索匹配

match():   根据模式匹配字符串，返回Match object对象
	&amp;gt;&amp;gt;&amp;gt; m = re.match(r&#39;www\.(.*)\..{3}&#39;,&#39;www.python.org&#39;)
	&amp;gt;&amp;gt;&amp;gt; m.group(1)
	&#39;python&#39;
	&amp;gt;&amp;gt;&amp;gt; m.group(0)
	&#39;www.python.org&#39;
	&amp;gt;&amp;gt;&amp;gt; m.start(1)
	4
	&amp;gt;&amp;gt;&amp;gt; m.end(1)
	10
	&amp;gt;&amp;gt;&amp;gt; m.span(1)
	(4, 10)
	&amp;gt;&amp;gt;&amp;gt; 
split():   根据模式的匹配项来分割字符串
	&amp;gt;&amp;gt;&amp;gt; import re
	&amp;gt;&amp;gt;&amp;gt; some_text = &#39;alpha,beta,,,,gamma delta&#39;
	&amp;gt;&amp;gt;&amp;gt; re.split(&#39;[, ]+&#39;,some_text)
	[&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;, &#39;delta&#39;]
	&amp;gt;&amp;gt;&amp;gt; re.split(&#39;[, ]+&#39;,some_text,maxsplit=2)
	[&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma delta&#39;]
	&amp;gt;&amp;gt;&amp;gt; re.split(&#39;[, ]+&#39;,some_text,maxsplit=1)
	[&#39;alpha&#39;, &#39;beta,,,,gamma delta&#39;]

findall(): 列出字符串中符合模式的所有匹配项
	&amp;gt;&amp;gt;&amp;gt; pat = &#39;[a-zA-Z]+&#39;
	&amp;gt;&amp;gt;&amp;gt; text = &#39;&quot;Hm...Err -- are you sure?&quot; he said, sounding insecure.&#39;
	&amp;gt;&amp;gt;&amp;gt; re.findall(pat,text)
	[&#39;Hm&#39;, &#39;Err&#39;, &#39;are&#39;, &#39;you&#39;, &#39;sure&#39;, &#39;he&#39;, &#39;said&#39;, &#39;sounding&#39;, &#39;insecure&#39;]
	&amp;gt;&amp;gt;&amp;gt; pat2 = r&#39;[.?\-&quot;,]+&#39;
	&amp;gt;&amp;gt;&amp;gt; re.findall(pat2,text)
	[&#39;&quot;&#39;, &#39;...&#39;, &#39;--&#39;, &#39;?&quot;&#39;, &#39;,&#39;, &#39;.&#39;]

sub():     利用表达式的匹配项替换指定的字符串
	&amp;gt;&amp;gt;&amp;gt; pat = &#39;{name}&#39;
	&amp;gt;&amp;gt;&amp;gt; text = &#39;Dear {name}&#39;
	&amp;gt;&amp;gt;&amp;gt; re.sub(pat,&#39;Mr,Gumby&#39;,text)
	&#39;Dear Mr,Gumby&#39;

escape():  转义正则表达式中所用的特殊字符
	&amp;gt;&amp;gt;&amp;gt; re.escape(&#39;www.python.org&#39;)
	&#39;www\\.python\\.org&#39;
	&amp;gt;&amp;gt;&amp;gt; re.escape(&#39;But where is the ambiguity?&#39;)
	&#39;But\\ where\\ is\\ the\\ ambiguity\\?&#39;
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Wed, 23 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/23/python6.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/23/python6.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>python基础知识点OOP总结</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;面向对象的思想虽然好理解，但是不同的语言的实现方式是有区别的，python的面向对象机制非常的灵活，也很优雅…..&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pythonoop&quot;&gt;python的OOP的实质&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;python的面向对象其实就是在已连接的命名空间对象上搜索属性
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里再次出现了命名空间，命名空间在python中的重要性再怎么强调也不为过。python中的命名空间本来是孤立的，但是因为OOP而将不同的命名空间联系了起来，从而我们可以形成一个命名空间组成的 “树状结构”，python的OOP机制就是在这个树状结构上的搜索机制，这就是python的OOP的本质所在。&lt;/p&gt;

&lt;h2 id=&quot;python&quot;&gt;python的类和继承&lt;/h2&gt;

&lt;p&gt;因为学习过java。感觉python的oop机制的实现还是比较粗糙的。当然也是比较灵活的，有动态语言的特定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A:
	pass

class B(A):
	pass

class C:
	pass

class D(A,C):
	pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里B继承了A；D继承了A和C。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A:
	def fun(self):
		self.action()

class B(A):
	def action(self):
		pass
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这里A作为基类，定义了方法fun，隐含了子类需要实现action方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python的继承搜索会现在实例对象中寻找属性，然后才是创建实例的类，之后是所有超类，当首次找到时，搜索就会停止。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类和实例对象都是命名空间，两者的主要区别是，类是建立实例的工厂，类也支持运算符重载方法，由实例继承。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类总是位于模块中，类是模块对象的属性，类和模块都是命名空间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类是通过运行class语句创建的；实例是像函数那样调用类来创建的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类属性的创建是通过把属性赋值给类对象实现的，类属性是由class语句中的顶层赋值语句产生的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实例属性是通过对实例对象赋值属性来创建的，实例属性一般是在class语句中的类方法函数中对self参数赋值属性而创建的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;self 通常是给类方法函数中的第一个参数的名称&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 22 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/22/python5.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/22/python5.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>python基础知识点模块和包</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;初次接触python对它的模块和包的概念感觉非常的绕，和java中的包的概念有很大的出入，总是迷迷糊糊的。这里记录一下自己的理解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;模块&lt;/h2&gt;

&lt;p&gt;模块其实就是Python代码组成的文本文件，其实也就是一个命名空间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在一个模块文件的顶层定义的所有变量都会成为被导入模块的属性&lt;/li&gt;
  &lt;li&gt;导入给予了对模块的全局作用域中的变量名的读取权也就是在模块导入后，模块文件的全局作用域变成了模块对象的命名空间&lt;/li&gt;
  &lt;li&gt;模块其实就是变量名的软件包&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;import和from语句都是可执行的赋值语句&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; a.py
 b.py
 两个文件
 在模块a.py中执行

 import b
 效果是先执行b.py中的代码，然后在a.py中定义了一个变量b，引用了b.py的命名空间
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;import 和 from … import …&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; from module import name1,name2

 等价于下面的语句

 import module
 name1 = module.name1
 name2 = module.name2
 del module
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;如果属性名前面有&lt;code&gt;_&lt;/code&gt;,就不会被&lt;code&gt;from c import *&lt;/code&gt;导入&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;模块的作用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;代码重用&lt;/li&gt;
  &lt;li&gt;系统命名空间划分&lt;/li&gt;
  &lt;li&gt;实现数据和服务的共享&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;包&lt;/h2&gt;

&lt;p&gt;python代码以及其所在的目录就是包。包的容器目录（顶层目录）需要能在搜索列表中存在，包其实也是一种命名空间&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只有&lt;code&gt;__init__.py&lt;/code&gt;文件的目录才能称之为包&lt;/li&gt;
  &lt;li&gt;包导入就是把计算机上的目录变成一个Python命名空间，而这个命名空间的属性则是对应目录中的子目录和模块文件&lt;/li&gt;
  &lt;li&gt;包导入之后，包就和模块没什么区别了&lt;/li&gt;
  &lt;li&gt;包第一次导入时，会自动执行&lt;code&gt;__init__.py&lt;/code&gt;文件中的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;分发与安装&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;注意关注 &lt;code&gt;distutils&lt;/code&gt; 这个工具的使用&lt;/li&gt;
  &lt;li&gt;注意关注 &lt;code&gt;eggs&lt;/code&gt; 这个开源系统的使用&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 21 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/21/python4.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/21/python4.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>python基础知识点之文件输入和输出</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#openfile&quot; id=&quot;markdown-toc-openfile&quot;&gt;open()，file()功能相同&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;文件对象的方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;文件内建属性&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;内建函数 open() [以及 file()]提供了初始化输入/输出(I/O)操作的通用接口,是打开文件之门的”钥匙”…..&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;openfile&quot;&gt;open()，file()功能相同&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;file_object = open(file_name, access_mode=&#39;r&#39;, buffering=-1)

file_name:是包含要打开文件名的字符串
access_mode:是一个字符串，代表文件打开的模式，模式后面会详解
buffering:指示访问文件所采用的缓冲方式,一般使用系统默认机制即可

文件模式 	操作
r 		以读方式打开
rU或Ua 	   	以读方式打开, 同时提供通用换行符支持 (PEP 278)
w 		以写方式打开 (必要时清空)
a 		以追加模式打开 (从 EOF 开始, 必要时创建新文件)
r+		以读写模式打开
w+ 		以读写模式打开 (参见 w )
a+ 		以读写模式打开 (参见 a )
rb 		以二进制读模式打开
wb 		以二进制写模式打开 (参见 w )
ab 		以二进制追加模式打开 (参见 a )
rb+ 		以二进制读写模式打开 (参见 r+ )
wb+ 		以二进制读写模式打开 (参见 w+ )
ab+ 		以二进制读写模式打开 (参见 a+ )


fp = open(&#39;/etc/motd&#39;) 		# 以读方式打开
fp = open(&#39;test&#39;, &#39;w&#39;) 		# 以写方式打开
fp = open(&#39;data&#39;, &#39;r+&#39;) 	# 以读写方式打开
fp = open(&#39;c:\io.sys&#39;, &#39;rb&#39;) 	# 以二进制读模式打开
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;文件对象的方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;file.close()			#关闭文件
file.flush()			#刷新文件的内部缓冲区
file.readline(size=-1)		#从文件中读取并返回一行(包括行结束符), 或返回最大 size个字符
file.readlines(sizhint=0)	#读取文件的所有行并作为一个列表返回(包含所有的行结束符); 如果给定 sizhint 且大于 0 , 那么将返回总和大约为sizhint 字节的行(大小由缓冲器容量的下一个值决定）（ 比如说缓冲器的大小只能为4K 的倍数，如果sizhint 为15k，则最后返回的可能是16k———译者按)
file.xreadlines()		#用于迭代, 可以替换 readlines() 的一个更高效的方法
file.tell()			#返回当前在文件中的位置
file.seek(off, whence=0)	#在文件中移动文件指针, 从 whence ( 0 代表文件其始, 1 代表当前位置, 2 代表文件末尾)偏移 off 字节
file.write(str)			#向文件写入字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;文件内建属性&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;file.name		#文件名
file.closed		#True 表示文件已经被关闭, 否则为 False
file.encoding		#文件所使用的编码 - 当 Unicode 字符串被写入数据时, 它们将自动使用 file.encoding 转换为字节字符串; 若file.encoding 为 None 时使用系统默认编码
file.mode		#文件打开时使用的访问模式
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 20 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/20/python3.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/20/python3.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>python基础知识点之易错语法</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#python-&quot; id=&quot;markdown-toc-python-&quot;&gt;python 语法基本原则&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;条件语句&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#if&quot; id=&quot;markdown-toc-if&quot;&gt;if语句&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;条件表达式&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;循环语句&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#while&quot; id=&quot;markdown-toc-while&quot;&gt;while语句&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#for&quot; id=&quot;markdown-toc-for&quot;&gt;for语句&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;迭代器和生成器&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;函数要注意的地方&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;变量的作用域&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;python的语法结构非常的简单，尤其是对于熟悉其他原因的人来说，但是还是会有一些细节需要注意的，这里仅仅记录一下重要的细节&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;python-&quot;&gt;python 语法基本原则&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;python语法和vb的语法有很大的相似性，都要求严格的缩进，用缩进来保证语法格式。而且冒号&lt;code&gt;:&lt;/code&gt;在python语法中有特殊的含义。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python中没有自增自减运算&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python中没有switch语句&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python中没有foreach语句&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python中的else和其他语言不同，可以用在循环语句中，表示循环完成后执行&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;条件语句&lt;/h2&gt;

&lt;h3 id=&quot;if&quot;&gt;if语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if expression:
	expr_true_suite
elif expression:
	expr_true_suite
else:
	expr_false_suite
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;条件表达式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;X if C else Y

a = x if x&amp;lt;y else y
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;循环语句&lt;/h2&gt;

&lt;h3 id=&quot;while&quot;&gt;while语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;while expression:
	suite_to_repeat
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;for&quot;&gt;for语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;for iter_var in iterable:
	suite_to_repeat
for语句经常和range()内建函数联合使用.
range()内建函数的语法：
range(start, end, step =1)  ;包前不包后

range(2,9,2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;迭代器和生成器&lt;/h3&gt;

&lt;p&gt;迭代器和生成器是python中的神器。后面会进行详细的总结。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;列表解析:
[expr for iter_var in iterable if cond_expr]
生成器表达式:
(expr for iter_var in iterable if cond_expr)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;函数要注意的地方&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;函数定义的第一行的字符串是文档字符串。写文档字符串是一个好习惯&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数的形参有很多种定义方法&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 1,直接定义
     def fun(x=1,y=2):
         print x,y
     fun(1,2)
     1,2

 2,形参前一个*代表传递的是元组
     def fun(*param):
         print param
     fun(1,2)
     (1,2)
	
 3,形参前两个*代表传递的是字典
     def fun(**param):
         print param
     fun(x=1,y=2)
     {&#39;x&#39;=1,&#39;y&#39;=2}
	
 4,传递参数时候的反转，将元组或字典拆开传递给函数
     def fun(x,y)
         return x+y
     params = (1,2)
     fun(*params)
     3
		
     def fun(job = &#39;x&#39;,name = &#39;y&#39;):
         print &#39;name :&#39;+name+&quot; job : &#39;+job

     params = {&#39;name&#39;:&#39;fulin&#39;,&#39;job&#39;:&#39;it&#39;}
     fun(**params)
     &#39;name :fulin job : it&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;变量的作用域&lt;/h2&gt;

&lt;p&gt;作用域其实就是命名空间，在哪里声明的变量，命名空间就是那里。这里有一个原则：LEGB原则。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;L:本地作用域，函数内的名字空间，包括局部变量和形参
E:嵌套作用域，外部嵌套函数的名字空间（闭包中常见）
G:全局作用域，全局变量，函数定义所在模块的名字空间
B:内置作用域，内置模块的名字空间
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;python的变量作用域和其他语言有比较大的区别，是一个难点，需要特别留意&lt;/p&gt;

</description>
        <pubDate>Sat, 19 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/19/python2.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/19/python2.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>python基础知识点之数据结构</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序列&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;字符串&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;元组&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;集合&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;字典&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;python中的数据结构大致可以分为三类：序列，映射，集合。这里详细的总结一下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;序列&lt;/h2&gt;

&lt;p&gt;序列的成员有序排列的，并且可以通过下标偏移量访问到它的一个或者几个成员,有序是序列的灵魂。序列有一些通用的方法：连接，重复，切片。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;连接（+）&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sq1 = [12,3]
 sq2 = [5,6]
 sq1 + sq2
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重复（*）&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sq1 = [12,3]
 sq1 * 2
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切片（[], [:], [::]）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

 	&lt;img src=&quot;/image/python_list.PNG&quot; alt=&quot;&quot; /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;字符串&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创建字符串&lt;/p&gt;

    &lt;p&gt;python中创建字符串没有单引号和双引号之分。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  str1 = &quot;fulin&quot;
  str2 = &#39;fulin&#39;
  str3 = str(&#39;fulin&#39;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串的方法&lt;/p&gt;

    &lt;p&gt;字符串的方法太多，这里不做过多的总结了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;列表&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创建列表&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  list1 = [1,2,3]
  list2 = [1,2,[2,3]]
  list3 = list()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;列表的方法&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  list.append(obj)		#向列表中添加一个对象obj
  list.count(obj)		#返回一个对象obj 在列表中出现的次数
  list.extend(seq)		#把序列seq 的内容添加到列表中
  list.remove(obj)		#从列表中删除对象obj
  list.reverse()		#原地翻转列表
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;元组&lt;/h3&gt;

&lt;p&gt;元组这里没有什么好说的，但要记住一点：元组是不可变序列，在python中有三种数据类型是不可变的：数字，字符串，元组。  &lt;br /&gt;
 虽然元组不可变，但是元组的元素如果是引用类型，其值是可变的。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;集合&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创建集合&lt;/p&gt;

    &lt;p&gt;这里的集合和数学中的集合概念差不多，就是容纳不同元素的容器，不过python中的集合分两类：&lt;code&gt;可变集合&lt;/code&gt; 和 &lt;code&gt;不可变集合&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  s = set([1,2,3]) //set()方法产生一个可变集合
  s1= frozenset([1,2,4]) //frozenset()方法产生一个不可变集合
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;集合的运算&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  set1 = set([1,2,3])	
      //创建集合
  set2 = set([1,2,4])	
      //创建集合
  set1 | set2 		
      //两集合的并集，输出：{1，2，3，4}
  set1 &amp;amp; set2 		
      //两集合的交集，输出：{1,2}
  set1 - set2		
      //两集合的差集相对差集，set1去掉set2中有的元素,输出:{3}
  set1 ^ set2 		
      //两集合的对称差集,set1有且set2无或set2有且set1无，输出：{3,4}
  set1 == set2 		
      //判断两集合的元素是否相同
  set1 != set2 		
      //判断两集合的元素是否是不相同
  set1 &amp;lt; set2 		
      //判断set1是否是set2的真子集
  set1 &amp;lt;= set2		
      //判断set1是否是set2的子集
  set1 &amp;gt; set2		
      //判断set2是否是set1的真子集
  set1 &amp;gt;=set2		
      //判断set2是否是set1的子集
  1 in set1		
      //判断1是否是set1的成员
  1 not in set1		
      //判断1是否不是set1的成员
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;集合的操作(方法)&lt;/p&gt;

    &lt;p&gt;集合的方法应该分两类，一类是可变集合的，一类是不可变集合的，但是在使用的时候，根据方法的功能，应该是很好区分的，这里不做区分。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  set1.add(5)		
      //向set1中添加元素
  set1.update([1,2,3])	
      //向set1中一次添加多个元素
  set1.remove(1)		
      //删除set1中的元素1，如果set1中不存在1则引发异常

  s.issubset(t)		
      //如果s 是t 的子集，则返回True,否则返回False
  s.issuperset(t) 	
      //如果s 是t 的超集，则返回True,否则返回False
  s.union(t) 			
      //返回一个新集合，该集合是s 和t 的并集
  s.intersection(t)	
      //返回一个新集合，该集合是s 和t 的交集
  s.difference(t)		
      //返回一个新集合，该集合是s 的成员，但不是t 的成员
  s.symmetric_difference(t)	
      //返回一个新集合，该集合是s或t的成员，但不是s 和t 共有的成员
  s.copy()		
      //返回一个新集合，它是集合s 的浅复制
  s.pop() 		
      //移除并返回s 中的任意一个元素
  s.clear() 		
      //清除操作: 移除s 中的所有元素
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;集合的运算，如果运算符两边的集合类型一个是可变集合，一个是不可变集合，则运算的结果的类型以运算符左边的类型为准&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-5&quot;&gt;字典&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创建字典&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; dic1 = {}	//创建一个空字典
 dic2 = {&#39;name&#39;:&#39;fulin&#39;,&#39;age&#39;:27}    //创建一个有两个元素的字段
 dic3 = dict()		//用dict()内建函数创建一个空字典
 dic4 = dict(([&#39;x&#39;,1],[&#39;y&#39;,2])) 
 dic5 = {}.fromkeys((&#39;x&#39;,&#39;y&#39;,&#39;z&#39;),-1)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;操作字典&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; del dict2[&#39;name&#39;] 		#删除键为“name”的条目
 dict2.clear()			#删除dict2 中所有的条目
 del dict2				#删除整个dict2 字典
 dict2.pop(&#39;name&#39;)		#删除并返回键为“name”的条目
 &#39;fu&#39; in dict2			#检查dict2中是否有键&#39;fu&#39;
 &#39;fu&#39; not in dict2		#检查dict2中是否没有键&#39;fu&#39;

 dict.copy() 			#返回字典(浅复制)的一个副本
 dict.get(key,
 default=None)			#对字典dict 中的键key,返回它对应的值value，如果字典中不存在此键，则返回default 的值(注意，参数default 的默认值为None)
 dict.items() 			#返回一个包含字典中(键, 值)对元组的列表
 dict.keys() 			#返回一个包含字典中键的列表
 dict.popc(key[, default]) #和方法get()相似，如果字典中key 键存在，删除并返回dict[key]，如果key 键不存在，且没有给出default 的值，引发KeyError 异常。
 dict.update(dict2)		#将字典dict2 的键-值对添加到字典dict
 dict.values() 			#返回一个包含字典中所有值的列表
 dict.setdefault(key,default=None) #和方法set()相似，如果字典中不存在key 键，由dict[key]=default 为它赋值。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 18 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/18/python1.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/18/python1.html</guid>
        
        
        <category>python</category>
        
      </item>
    
  </channel>
</rss>
