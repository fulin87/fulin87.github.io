<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2B程序员的笔记</title>
    <description></description>
    <link>http://colorful.ren/</link>
    <atom:link href="http://colorful.ren/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 06 Dec 2016 16:44:31 +0800</pubDate>
    <lastBuildDate>Tue, 06 Dec 2016 16:44:31 +0800</lastBuildDate>
    <generator>Jekyll v3.0.0</generator>
    
      <item>
        <title>python基础知识点OOP总结</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;面向对象的思想虽然好理解，但是不同的语言的实现方式是有区别的，python的面向对象机制非常的灵活，也很优雅…..&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pythonoop&quot;&gt;python的OOP的实质&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;python的面向对象其实就是在已连接的命名空间对象上搜索属性
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里再次出现了命名空间，命名空间在python中的重要性再怎么强调也不为过。python中的命名空间本来是孤立的，但是因为OOP而将不同的命名空间联系了起来，从而我们可以形成一个命名空间组成的 “树状结构”，python的OOP机制就是在这个树状结构上的搜索机制，这就是python的OOP的本质所在。&lt;/p&gt;

&lt;h2 id=&quot;python&quot;&gt;python的类和继承&lt;/h2&gt;

&lt;p&gt;因为学习过java。感觉python的oop机制的实现还是比较粗糙的。当然也是比较灵活的，有动态语言的特定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A:
	pass

class B(A):
	pass

class C:
	pass

class D(A,C):
	pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里B继承了A；D继承了A和C。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A:
	def fun(self):
		self.action()

class B(A):
	def action(self):
		pass
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这里A作为基类，定义了方法fun，隐含了子类需要实现action方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python的继承搜索会现在实例对象中寻找属性，然后才是创建实例的类，之后是所有超类，当首次找到时，搜索就会停止。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类和实例对象都是命名空间，两者的主要区别是，类是建立实例的工厂，类也支持运算符重载方法，由实例继承。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类总是位于模块中，类是模块对象的属性，类和模块都是命名空间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类是通过运行class语句创建的；实例是像函数那样调用类来创建的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类属性的创建是通过把属性赋值给类对象实现的，类属性是由class语句中的顶层赋值语句产生的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实例属性是通过对实例对象赋值属性来创建的，实例属性一般是在class语句中的类方法函数中对self参数赋值属性而创建的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;self 通常是给类方法函数中的第一个参数的名称&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 22 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/22/python5.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/22/python5.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>python基础知识点模块和包</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;初次接触python对它的模块和包的概念感觉非常的绕，和java中的包的概念有很大的出入，总是迷迷糊糊的。这里记录一下自己的理解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;模块&lt;/h2&gt;

&lt;p&gt;模块其实就是Python代码组成的文本文件，其实也就是一个命名空间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在一个模块文件的顶层定义的所有变量都会成为被导入模块的属性&lt;/li&gt;
  &lt;li&gt;导入给予了对模块的全局作用域中的变量名的读取权也就是在模块导入后，模块文件的全局作用域变成了模块对象的命名空间&lt;/li&gt;
  &lt;li&gt;模块其实就是变量名的软件包&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;import和from语句都是可执行的赋值语句&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; a.py
 b.py
 两个文件
 在模块a.py中执行

 import b
 效果是先执行b.py中的代码，然后在a.py中定义了一个变量b，引用了b.py的命名空间
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;import 和 from … import …&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; from module import name1,name2

 等价于下面的语句

 import module
 name1 = module.name1
 name2 = module.name2
 del module
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;如果属性名前面有&lt;code&gt;_&lt;/code&gt;,就不会被&lt;code&gt;from c import *&lt;/code&gt;导入&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;模块的作用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;代码重用&lt;/li&gt;
  &lt;li&gt;系统命名空间划分&lt;/li&gt;
  &lt;li&gt;实现数据和服务的共享&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;包&lt;/h2&gt;

&lt;p&gt;python代码以及其所在的目录就是包。包的容器目录（顶层目录）需要能在搜索列表中存在，包其实也是一种命名空间&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只有&lt;code&gt;__init__.py&lt;/code&gt;文件的目录才能称之为包&lt;/li&gt;
  &lt;li&gt;包导入就是把计算机上的目录变成一个Python命名空间，而这个命名空间的属性则是对应目录中的子目录和模块文件&lt;/li&gt;
  &lt;li&gt;包导入之后，包就和模块没什么区别了&lt;/li&gt;
  &lt;li&gt;包第一次导入时，会自动执行&lt;code&gt;__init__.py&lt;/code&gt;文件中的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;分发与安装&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;注意关注 &lt;code&gt;distutils&lt;/code&gt; 这个工具的使用&lt;/li&gt;
  &lt;li&gt;注意关注 &lt;code&gt;eggs&lt;/code&gt; 这个开源系统的使用&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 21 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/21/python4.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/21/python4.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>python基础知识点之文件输入和输出</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#openfile&quot; id=&quot;markdown-toc-openfile&quot;&gt;open()，file()功能相同&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;文件对象的方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;文件内建属性&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;内建函数 open() [以及 file()]提供了初始化输入/输出(I/O)操作的通用接口,是打开文件之门的”钥匙”…..&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;openfile&quot;&gt;open()，file()功能相同&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;file_object = open(file_name, access_mode=&#39;r&#39;, buffering=-1)

file_name:是包含要打开文件名的字符串
access_mode:是一个字符串，代表文件打开的模式，模式后面会详解
buffering:指示访问文件所采用的缓冲方式,一般使用系统默认机制即可

文件模式 	操作
r 		以读方式打开
rU或Ua 	   	以读方式打开, 同时提供通用换行符支持 (PEP 278)
w 		以写方式打开 (必要时清空)
a 		以追加模式打开 (从 EOF 开始, 必要时创建新文件)
r+		以读写模式打开
w+ 		以读写模式打开 (参见 w )
a+ 		以读写模式打开 (参见 a )
rb 		以二进制读模式打开
wb 		以二进制写模式打开 (参见 w )
ab 		以二进制追加模式打开 (参见 a )
rb+ 		以二进制读写模式打开 (参见 r+ )
wb+ 		以二进制读写模式打开 (参见 w+ )
ab+ 		以二进制读写模式打开 (参见 a+ )


fp = open(&#39;/etc/motd&#39;) 		# 以读方式打开
fp = open(&#39;test&#39;, &#39;w&#39;) 		# 以写方式打开
fp = open(&#39;data&#39;, &#39;r+&#39;) 	# 以读写方式打开
fp = open(&#39;c:\io.sys&#39;, &#39;rb&#39;) 	# 以二进制读模式打开
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;文件对象的方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;file.close()			#关闭文件
file.flush()			#刷新文件的内部缓冲区
file.readline(size=-1)		#从文件中读取并返回一行(包括行结束符), 或返回最大 size个字符
file.readlines(sizhint=0)	#读取文件的所有行并作为一个列表返回(包含所有的行结束符); 如果给定 sizhint 且大于 0 , 那么将返回总和大约为sizhint 字节的行(大小由缓冲器容量的下一个值决定）（ 比如说缓冲器的大小只能为4K 的倍数，如果sizhint 为15k，则最后返回的可能是16k———译者按)
file.xreadlines()		#用于迭代, 可以替换 readlines() 的一个更高效的方法
file.tell()			#返回当前在文件中的位置
file.seek(off, whence=0)	#在文件中移动文件指针, 从 whence ( 0 代表文件其始, 1 代表当前位置, 2 代表文件末尾)偏移 off 字节
file.write(str)			#向文件写入字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;文件内建属性&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;file.name		#文件名
file.closed		#True 表示文件已经被关闭, 否则为 False
file.encoding		#文件所使用的编码 - 当 Unicode 字符串被写入数据时, 它们将自动使用 file.encoding 转换为字节字符串; 若file.encoding 为 None 时使用系统默认编码
file.mode		#文件打开时使用的访问模式
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 20 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/20/python3.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/20/python3.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>python基础知识点之易错语法</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#python-&quot; id=&quot;markdown-toc-python-&quot;&gt;python 语法基本原则&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;条件语句&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#if&quot; id=&quot;markdown-toc-if&quot;&gt;if语句&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;条件表达式&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;循环语句&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#while&quot; id=&quot;markdown-toc-while&quot;&gt;while语句&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#for&quot; id=&quot;markdown-toc-for&quot;&gt;for语句&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;迭代器和生成器&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;函数要注意的地方&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;变量的作用域&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;python的语法结构非常的简单，尤其是对于熟悉其他原因的人来说，但是还是会有一些细节需要注意的，这里仅仅记录一下重要的细节&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;python-&quot;&gt;python 语法基本原则&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;python语法和vb的语法有很大的相似性，都要求严格的缩进，用缩进来保证语法格式。而且冒号&lt;code&gt;:&lt;/code&gt;在python语法中有特殊的含义。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python中没有自增自减运算&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python中没有switch语句&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python中没有foreach语句&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python中的else和其他语言不同，可以用在循环语句中，表示循环完成后执行&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;条件语句&lt;/h2&gt;

&lt;h3 id=&quot;if&quot;&gt;if语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if expression:
	expr_true_suite
elif expression:
	expr_true_suite
else:
	expr_false_suite
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;条件表达式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;X if C else Y

a = x if x&amp;lt;y else y
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;循环语句&lt;/h2&gt;

&lt;h3 id=&quot;while&quot;&gt;while语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;while expression:
	suite_to_repeat
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;for&quot;&gt;for语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;for iter_var in iterable:
	suite_to_repeat
for语句经常和range()内建函数联合使用.
range()内建函数的语法：
range(start, end, step =1)  ;包前不包后

range(2,9,2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;迭代器和生成器&lt;/h3&gt;

&lt;p&gt;迭代器和生成器是python中的神器。后面会进行详细的总结。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;列表解析:
[expr for iter_var in iterable if cond_expr]
生成器表达式:
(expr for iter_var in iterable if cond_expr)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;函数要注意的地方&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;函数定义的第一行的字符串是文档字符串。写文档字符串是一个好习惯&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数的形参有很多种定义方法&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 1,直接定义
     def fun(x=1,y=2):
         print x,y
     fun(1,2)
     1,2

 2,形参前一个*代表传递的是元组
     def fun(*param):
         print param
     fun(1,2)
     (1,2)
	
 3,形参前两个*代表传递的是字典
     def fun(**param):
         print param
     fun(x=1,y=2)
     {&#39;x&#39;=1,&#39;y&#39;=2}
	
 4,传递参数时候的反转，将元组或字典拆开传递给函数
     def fun(x,y)
         return x+y
     params = (1,2)
     fun(*params)
     3
		
     def fun(job = &#39;x&#39;,name = &#39;y&#39;):
         print &#39;name :&#39;+name+&quot; job : &#39;+job

     params = {&#39;name&#39;:&#39;fulin&#39;,&#39;job&#39;:&#39;it&#39;}
     fun(**params)
     &#39;name :fulin job : it&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;变量的作用域&lt;/h2&gt;

&lt;p&gt;作用域其实就是命名空间，在哪里声明的变量，命名空间就是那里。这里有一个原则：LEGB原则。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;L:本地作用域，函数内的名字空间，包括局部变量和形参
E:嵌套作用域，外部嵌套函数的名字空间（闭包中常见）
G:全局作用域，全局变量，函数定义所在模块的名字空间
B:内置作用域，内置模块的名字空间
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;python的变量作用域和其他语言有比较大的区别，是一个难点，需要特别留意&lt;/p&gt;

</description>
        <pubDate>Sat, 19 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/19/python2.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/19/python2.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>python基础知识点之数据结构</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序列&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;字符串&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;元组&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;集合&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;字典&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;python中的数据结构大致可以分为三类：序列，映射，集合。这里详细的总结一下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;序列&lt;/h2&gt;

&lt;p&gt;序列的成员有序排列的，并且可以通过下标偏移量访问到它的一个或者几个成员,有序是序列的灵魂。序列有一些通用的方法：连接，重复，切片。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;连接（+）&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sq1 = [12,3]
 sq2 = [5,6]
 sq1 + sq2
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重复（*）&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sq1 = [12,3]
 sq1 * 2
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切片（[], [:], [::]）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

 	&lt;img src=&quot;/image/python_list.PNG&quot; alt=&quot;&quot; /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;字符串&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创建字符串&lt;/p&gt;

    &lt;p&gt;python中创建字符串没有单引号和双引号之分。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  str1 = &quot;fulin&quot;
  str2 = &#39;fulin&#39;
  str3 = str(&#39;fulin&#39;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串的方法&lt;/p&gt;

    &lt;p&gt;字符串的方法太多，这里不做过多的总结了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;列表&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创建列表&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  list1 = [1,2,3]
  list2 = [1,2,[2,3]]
  list3 = list()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;列表的方法&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  list.append(obj)		#向列表中添加一个对象obj
  list.count(obj)		#返回一个对象obj 在列表中出现的次数
  list.extend(seq)		#把序列seq 的内容添加到列表中
  list.remove(obj)		#从列表中删除对象obj
  list.reverse()		#原地翻转列表
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;元组&lt;/h3&gt;

&lt;p&gt;元组这里没有什么好说的，但要记住一点：元组是不可变序列，在python中有三种数据类型是不可变的：数字，字符串，元组。  &lt;br /&gt;
 虽然元组不可变，但是元组的元素如果是引用类型，其值是可变的。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;集合&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创建集合&lt;/p&gt;

    &lt;p&gt;这里的集合和数学中的集合概念差不多，就是容纳不同元素的容器，不过python中的集合分两类：&lt;code&gt;可变集合&lt;/code&gt; 和 &lt;code&gt;不可变集合&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  s = set([1,2,3]) //set()方法产生一个可变集合
  s1= frozenset([1,2,4]) //frozenset()方法产生一个不可变集合
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;集合的运算&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  set1 = set([1,2,3])	
      //创建集合
  set2 = set([1,2,4])	
      //创建集合
  set1 | set2 		
      //两集合的并集，输出：{1，2，3，4}
  set1 &amp;amp; set2 		
      //两集合的交集，输出：{1,2}
  set1 - set2		
      //两集合的差集相对差集，set1去掉set2中有的元素,输出:{3}
  set1 ^ set2 		
      //两集合的对称差集,set1有且set2无或set2有且set1无，输出：{3,4}
  set1 == set2 		
      //判断两集合的元素是否相同
  set1 != set2 		
      //判断两集合的元素是否是不相同
  set1 &amp;lt; set2 		
      //判断set1是否是set2的真子集
  set1 &amp;lt;= set2		
      //判断set1是否是set2的子集
  set1 &amp;gt; set2		
      //判断set2是否是set1的真子集
  set1 &amp;gt;=set2		
      //判断set2是否是set1的子集
  1 in set1		
      //判断1是否是set1的成员
  1 not in set1		
      //判断1是否不是set1的成员
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;集合的操作(方法)&lt;/p&gt;

    &lt;p&gt;集合的方法应该分两类，一类是可变集合的，一类是不可变集合的，但是在使用的时候，根据方法的功能，应该是很好区分的，这里不做区分。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  set1.add(5)		
      //向set1中添加元素
  set1.update([1,2,3])	
      //向set1中一次添加多个元素
  set1.remove(1)		
      //删除set1中的元素1，如果set1中不存在1则引发异常

  s.issubset(t)		
      //如果s 是t 的子集，则返回True,否则返回False
  s.issuperset(t) 	
      //如果s 是t 的超集，则返回True,否则返回False
  s.union(t) 			
      //返回一个新集合，该集合是s 和t 的并集
  s.intersection(t)	
      //返回一个新集合，该集合是s 和t 的交集
  s.difference(t)		
      //返回一个新集合，该集合是s 的成员，但不是t 的成员
  s.symmetric_difference(t)	
      //返回一个新集合，该集合是s或t的成员，但不是s 和t 共有的成员
  s.copy()		
      //返回一个新集合，它是集合s 的浅复制
  s.pop() 		
      //移除并返回s 中的任意一个元素
  s.clear() 		
      //清除操作: 移除s 中的所有元素
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;集合的运算，如果运算符两边的集合类型一个是可变集合，一个是不可变集合，则运算的结果的类型以运算符左边的类型为准&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-5&quot;&gt;字典&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创建字典&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; dic1 = {}	//创建一个空字典
 dic2 = {&#39;name&#39;:&#39;fulin&#39;,&#39;age&#39;:27}    //创建一个有两个元素的字段
 dic3 = dict()		//用dict()内建函数创建一个空字典
 dic4 = dict(([&#39;x&#39;,1],[&#39;y&#39;,2])) 
 dic5 = {}.fromkeys((&#39;x&#39;,&#39;y&#39;,&#39;z&#39;),-1)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;操作字典&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; del dict2[&#39;name&#39;] 		#删除键为“name”的条目
 dict2.clear()			#删除dict2 中所有的条目
 del dict2				#删除整个dict2 字典
 dict2.pop(&#39;name&#39;)		#删除并返回键为“name”的条目
 &#39;fu&#39; in dict2			#检查dict2中是否有键&#39;fu&#39;
 &#39;fu&#39; not in dict2		#检查dict2中是否没有键&#39;fu&#39;

 dict.copy() 			#返回字典(浅复制)的一个副本
 dict.get(key,
 default=None)			#对字典dict 中的键key,返回它对应的值value，如果字典中不存在此键，则返回default 的值(注意，参数default 的默认值为None)
 dict.items() 			#返回一个包含字典中(键, 值)对元组的列表
 dict.keys() 			#返回一个包含字典中键的列表
 dict.popc(key[, default]) #和方法get()相似，如果字典中key 键存在，删除并返回dict[key]，如果key 键不存在，且没有给出default 的值，引发KeyError 异常。
 dict.update(dict2)		#将字典dict2 的键-值对添加到字典dict
 dict.values() 			#返回一个包含字典中所有值的列表
 dict.setdefault(key,default=None) #和方法set()相似，如果字典中不存在key 键，由dict[key]=default 为它赋值。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 18 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/18/python1.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/18/python1.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>python基础知识点之环境</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#pythonpip&quot; id=&quot;markdown-toc-pythonpip&quot;&gt;python的包管理工具pip&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pip&quot; id=&quot;markdown-toc-pip&quot;&gt;pip工具的使用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pythonipython&quot; id=&quot;markdown-toc-pythonipython&quot;&gt;python的命令行开发工具ipython&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;学习java的时候，都知道java有很多优秀的第三方jar包，但是管理这些jar包真是一件麻烦事，虽然有像maven这样的依赖管理工具，但是学习成本还是蛮高的。
python 的包管理工具pip使用起来非常的舒服，一条命令就可以搞定下载安装，再用不用为包的管理而烦恼了，让人想起那句著名的话：&lt;strong&gt;less is more&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pythonpip&quot;&gt;python的包管理工具pip&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;访问：&lt;a href=&quot;https://bootstrap.pypa.io/get-pip.py&quot;&gt;get-pip.py&lt;/a&gt; 访问需要的python文件。&lt;/li&gt;
  &lt;li&gt;将源代码copy到一个文本文件，将文本文件重命名的get-pip.py。&lt;/li&gt;
  &lt;li&gt;通过命令行进入上述文本文件的所在位置，运行一下命令： &lt;code&gt;python get-pip.py&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pip&quot;&gt;pip工具的使用&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;pip list              //查看已经安装的python包
pip show package      //查看packageName的详细情况
pip install package   //安装包package
pip uninstall package //卸载包package
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;pythonipython&quot;&gt;python的命令行开发工具ipython&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;pip install ipython  //安装ipython
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;很多时候，配置一个开发环境不容易，这是一个学习的过程，也是一个过坑的过程，把这些过程记录下来，战胜自己的遗忘&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Nov 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/python/2016/11/17/python0.html</link>
        <guid isPermaLink="true">http://colorful.ren/python/2016/11/17/python0.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>windows软件图标异常的恢复方法</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;作为一个有轻微强迫症的用户，遇到一点不协调的东西，都会有点不舒服，一周以前，我电脑中的outlook图标出现了异常，变成了很难看的样子，一直想把这个图标恢复，没有找到什么好的办法，咨询了很多人，也没有解决，这个事一直耿耿于怀，直到今天，才解决，这里记录一下解决办法……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;异常之后的图标&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/image/out_look_err.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解决办法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1,切换至用户家目录中的本地数据目录，比如我的目录是：C：\User\870850\AppData\Local
2,找到文件：iconcache.db
3,将iconcache.db文件删除
4,重启系统
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;C：\User\870850\AppData\Local\iconcache.db&lt;/code&gt; 文件是一个缓存的数据文件，存储着系统中应用程序的图标等信息。将其删除后，系统重启时在explorer.exe程序启动时，会重建这个文件，也就会解决图标异常的问题了。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;解决之后&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/image/out_look_right.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这下看着舒服多了，哈哈哈！！！！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 29 Oct 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/life/2016/10/29/outlookerr.html</link>
        <guid isPermaLink="true">http://colorful.ren/life/2016/10/29/outlookerr.html</guid>
        
        
        <category>life</category>
        
      </item>
    
      <item>
        <title>Excel VBA工程密码破解的方法</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;今天无意中发现一个破解Excel VBA工程密码的方法，经测试在2003,2007,2010这三个版本上都可以正常使用，今记录在此。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;vba&quot;&gt;vba工程加密之后&lt;/h3&gt;

&lt;p&gt;对excel的VBA工程进行加密，是一种非常必要的手段，可以防止代码被人篡改。但是有时会出现密码遗忘的问题，怎么找回原来的密码或者重新设置密码呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/vba1.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;解决办法&lt;/h3&gt;

&lt;p&gt;偶然间发现一个很好的解决方法，使用HXD软件直接修改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/VBA2.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用HXD打开excel。&lt;/li&gt;
  &lt;li&gt;搜索“DPB=”，并替换成“DPx=”，保存文件。&lt;/li&gt;
  &lt;li&gt;打开文件了，对VBA工程进行修改密码，这一步非常重要不然还是看不了源代码。&lt;/li&gt;
  &lt;li&gt;再次打开exlel,用新的密码打开VBA工程，搞定！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/image/VBA3.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;操作之前一定要对原始数据进行备份，否则数据丢失，这是血的教训，切记，切记！！！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;内部机理&lt;/h3&gt;

&lt;p&gt;说实话，我还没有搞清楚内部的实现原理，先记录在这里，等搞明白了，在补充。&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Oct 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/excel/2016/10/27/vbamima.html</link>
        <guid isPermaLink="true">http://colorful.ren/excel/2016/10/27/vbamima.html</guid>
        
        
        <category>Excel</category>
        
      </item>
    
      <item>
        <title>Linux中的文件大小和磁盘占有空间的关系</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#crontab-&quot; id=&quot;markdown-toc-crontab-&quot;&gt;crontab 定时任务产生的问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;解决办法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;启示&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;文件的真实大小和文件占有的磁盘空间不是一回事，根本的原因是由于系统和磁盘的存储机制决定的。最具有代表性的是crontab定时任务执行之后由sendmail产生的文件。下面详细分析一下整个过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;crontab-&quot;&gt;crontab 定时任务产生的问题&lt;/h2&gt;

&lt;p&gt;现在有一台服务器A&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat /etc/redhat-release
Red Hat Enterprise Linux Server release 5.4 (Tikanga)

# rpm -qa|grep sendmail
sendmail-8.13.8-2.el5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是centos 5.4这个版本，而且已经安装了sendmail软件。&lt;/p&gt;

&lt;p&gt;有几个crontab定时任务
	# crontab -l&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 * * * * /data/jobscripts/run_status60.sh
0 * * * * /data/jobscripts/run_statusin.sh
*/5 7-23 * * * /data/jobscripts/run_sendsms.sh
*/5 * * * * /data/jobscripts/adjustment_product_store.sh
0 3 * * * /data/jobscripts/collate_product_store.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意这里这里的定时任务都没有对标准输出和标准错误输出进行重定向到/dev/null文件，那么这样做有什么隐患呢？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;定时任务启动之后，发现 &lt;code&gt;/var/spool/clientmqueue/&lt;/code&gt; 目录下的文件开始不断增加，这是一年之后我无意中发现的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls -lihd /var/spool/clientmqueue/
2080777 drwxrwx--- 2 smmsp smmsp 12M Oct 28 11:36 /var/spool/clientmqueue/

# du -h /var/spool/clientmqueue/
1.4G    /var/spool/clientmqueue/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现没有，目录 &lt;code&gt;/var/spool/clientmqueue/&lt;/code&gt; 实际的大小只有12M，但是占有的磁盘空间确达到了1.4G，是不是非常奇怪？继续排查。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls -lih /var/spool/clientmqueue/ | wc -l
345047

# ls -lih /var/spool/clientmqueue/ | head -5
total 1.4G
2080837 -rw-rw---- 1 smmsp smmsp  880 Jan 23  2014 dfs0NEf1nJ007902
2080823 -rw-rw---- 1 smmsp smmsp  880 Jan 23  2014 dfs0NEK15v025165
2080839 -rw-rw---- 1 smmsp smmsp  880 Jan 23  2014 dfs0NEp1UL009526
2080836 -rw-rw---- 1 smmsp smmsp  880 Jan 23  2014 dfs0NEV2M6006278
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到这里，才恍然大悟，原来 &lt;code&gt;/var/spool/clientmqueue/&lt;/code&gt; 这个目录中的文件有345047个之多，但是每个文件却只有880 byte 大。这就造成了磁盘Block的大量浪费，所以才会有目录磁盘占用量远大于目录本身大小的情况。&lt;/p&gt;

&lt;p&gt;那么这些小文件是怎么来的呢？其实是crontab定时任务在执行之后，就会尝试通过sendmail给任务所有者发送一个邮件，如果发现sendmail服务没有启动，就产生了一个880 byte的小文件，临时放在&lt;code&gt;/var/spool/clientmqueue/&lt;/code&gt;目录下，知道sendmail服务启动后才会清除。每次执行都产生一个，日积月累，数量非常庞大，给系统的安全还造成了一个隐患。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;解决办法&lt;/h2&gt;

&lt;p&gt;其实解决办法非常简单，将定时任务的标准输出和标准错误输出重定向到 &lt;code&gt;/dev/null&lt;/code&gt; 即可，将定时任务改造如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 * * * * /data/jobscripts/run_status60.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
0 * * * * /data/jobscripts/run_statusin.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
*/5 7-23 * * * /data/jobscripts/run_sendsms.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
*/5 * * * * /data/jobscripts/adjustment_product_store.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
0 3 * * * /data/jobscripts/collate_product_store.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里还有一个需要注意的地方，&lt;code&gt;/var/spool/clientmqueue/&lt;/code&gt; 这个目录下面有太多的文件，如果需要删除,使用 &lt;code&gt;rm -rf /var/spool/clientmqueue/*&lt;/code&gt;会发现删不了，因为文件太多，怎么办了，是有方法的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;方法一&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; ls /var/spool/clientmqueue/|xargs rm -f
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法二&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; find /var/spool/clientmqueue/ -type f|xargs rm -f
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法三&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 直接将目录   `/var/spool/clientmqueue/`	删除
 然后重建目录及给目录赋权限和属主和属组
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;启示&lt;/h2&gt;

&lt;p&gt;通过这个案例，知道了crontab定时任务有一个小小的风险，但是可以通过重定向到 &lt;code&gt;/dev/null&lt;/code&gt; 来解决。&lt;/p&gt;

&lt;p&gt;同时，对这个问题的深入剖析，可以帮助我们更加深刻的理解 Inode;Block 和文件存储的机制。&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Oct 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/linux/2016/10/27/fildanddisk.html</link>
        <guid isPermaLink="true">http://colorful.ren/linux/2016/10/27/fildanddisk.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>正则表达式知识点</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;基本正则表达式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;扩展正则表达式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;正则表达式就是一套处理字符串的规则和方法，基本上是以行为单位对字符串进行处理，通过特殊符号的辅助，我们可以快速的过滤替换字符串，&lt;code&gt;这里的正则表达式不是linux中所有命令都能用的，大部分是三剑客（sed,grep,awk）用的，和开发语言使用的正则表达式有区别&lt;/code&gt;。&lt;/p&gt;

  &lt;p&gt;这里作为自己常用的正则表达式的一个汇总，也作为复习使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;基本正则表达式&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;^dog&lt;/code&gt; 以dog开头&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; ls -l /home | grep ^d  #过滤出/home目录下的子目录
 grep -v ^# /home/config.conf #过滤掉config.conf中的注释内容
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;[^dog]&lt;/code&gt; 不包含dog&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;dog$&lt;/code&gt; 以dog结尾&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; ls -Fl /home | grep /$ #过滤出/home目录下的子目录
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;^$&lt;/code&gt; 表示空行&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;.&lt;/code&gt; 表示且只能表示一个任意字符&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; grep &quot;\.&quot; /home/config.conf #过滤出config.conf中包含.的行
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;*&lt;/code&gt; 重复0个或多个前面的一个字符&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.*&lt;/code&gt; 匹配所有字符&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;[]&lt;/code&gt; 配置包含有其中的字符的内容&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; grep &quot;[abc]&quot; /home/config.conf #匹配出不包含a,b,c字符的行
 grep &quot;[0-9]&quot; /home/config.conf #匹配出包含有数字的行
 grep &quot;[a-Z]&quot; /home/config.conf #匹配出包含有因为字符的行
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;[^]&lt;/code&gt; 作用和 &lt;code&gt;[]&lt;/code&gt; 刚好相反&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; grep &quot;[^0-9]&quot; /home/config.conf #匹配出含有数字之外字符的行
 grep &quot;[^a-Z]&quot; /home/config.conf #匹配出含有字母之外字符的行
 grep &quot;^[^t]&quot;  /home/config.conf #匹配出不是t开头的行
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;{n,m}&lt;/code&gt; 重复前一个字符n到m次&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;扩展正则表达式&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;+&lt;/code&gt; 重复前面的字符一次或多次&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; egrep &quot;s+&quot; /home/config.conf #匹配包含有s的行
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;?&lt;/code&gt; 重复0个或一个前面的字符&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; egrep &quot;s?&quot; /home/config.conf #匹配没有s或没有连续s的行
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;|&lt;/code&gt; 用或的方式查找多个符合条件的字符串
     egrep “ss|ff” /home/config.conf #匹配含有ss或ff的行&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 20 Oct 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/linux/2016/10/20/regular.html</link>
        <guid isPermaLink="true">http://colorful.ren/linux/2016/10/20/regular.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
  </channel>
</rss>
