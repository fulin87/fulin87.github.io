<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fulin87的笔记</title>
    <description></description>
    <link>http://colorful.ren/</link>
    <atom:link href="http://colorful.ren/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 22 Sep 2016 16:23:38 +0800</pubDate>
    <lastBuildDate>Thu, 22 Sep 2016 16:23:38 +0800</lastBuildDate>
    <generator>Jekyll v3.0.0</generator>
    
      <item>
        <title>mysql中sql优化的思路和原则</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;大部分系统的性能瓶颈都是IO操作，数据库的IO消耗是其中的重要组成部分，SQL语句性能的优化是很有必要的，如果一开始不注意，后期的改动成本是比较大的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;sql&quot;&gt;SQL优化的思路&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1.优化更需要优化的sql；
2.定位优化对象的性能瓶颈：优化前需了解查询的瓶颈是IO还是CPU可通过PROFILING很容易定位查询的瓶颈。
3.明确优化目标；
4.从Explain入手；
5.多使用profile；
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sql-1&quot;&gt;SQL优化的基本原则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;永远用小结果集驱动大结果集&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;From子句中sql解析顺序为从右向左，执行时会以最左边的表为基础表循环与右边表数据做笛卡尔积，所以以小结果集驱动能减少循环次数，从而减少对被驱动结果集的访问，从而减少被驱动表的锁定。&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;尽可能在索引中完成排序&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;排序算法有两种：a.查出排序字段和行指针，排序，再通过行指针获得行数据所需列，返回结果集；b.取出所有排序列数据，在排序缓冲区中排完序直接返回结果集。索引排序是利用索引的有序性对数据排序的。&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;只取出子集需要的colums&lt;/li&gt;
  &lt;li&gt;仅仅使用最有效的过滤条件&lt;/li&gt;
  &lt;li&gt;尽可能避免复杂的Join和子查询&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;索引相关的总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;什么是索引，可以把索引想象成数据库的目录，查找某一样东西之前，先在目录中确定好位置，直奔位置而去，这就是提高查询效率的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;索引的好处&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 提高数据检索效率，降低数据库的IO成本
 降低数据排序成本：要求排序字段和索引键字段一致
 降低数据分组成本：因为分组之前会先排序，同意如果分组字段与索引字段一致，会降低分组消耗的成本。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;索引的弊端&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 索引是独立于基础数据的数据库对象，因此它会占用存储空间
 数据新增、更新会导致索引的同步更新，所以会增加数据新增、更新所消耗的成本
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;否需要创建索引&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 较为频繁的作为查询条件的字段需要创建索引
 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
 更新非常频繁的字段不适合创建索引
 不会出现在where子句中的字段不要创建索引
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;索引语法&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;唯一索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD UNIQUE indexName (column);
  CREATE UNIQUE INDEX indexName ON tableName (column);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;普通索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD INDEX indexName(column);
  CREATE INDEX indexName ON tableName(column);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;主键索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD PRIMARY KEY (column);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;全文索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD FULLTEXT (column);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;组合索引&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  ALTER TABLE tableName ADD INDEX indexName(col1,col2,...);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 22 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/mysql/2016/09/22/mysql-update.html</link>
        <guid isPermaLink="true">http://colorful.ren/mysql/2016/09/22/mysql-update.html</guid>
        
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>mysql 基础知识</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;大道至简，世间的道理都是相似的……   &lt;br /&gt;
  就比如学东西吧，以前总是东学一点，西学一点。到头来发现什么都会，什么都不精，所以，到头来才明白：少才是多，less is more。数据库，以后就选择mysql了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;mysql&quot;&gt;mysql的安装&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;因为仅做学习使用，这里只讲centos下的 mysql 安装过程，其他环境下的不做过多解释。而且，这里介绍的也是最方便的安装过程，不一定是最好的方式&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;操作系统信息&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Description:		CentOS Linux release 7.2.1511 (Core) 
 Release:		7.2.1511
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首先查看本系统有没有安装 mariadb&lt;/p&gt;

   	$ rpm -qa |　grep -i mariadb    //这里的-i是忽略大小写

    &lt;pre&gt;&lt;code&gt;   mariadb-libs-5.5.44-2.el7.centos.x86_64
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果有安装，则需要卸载(–nodeps意思是如果有依赖关系，则同时卸载掉)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ rpm -e --nodeps mariadb-libs-5.5.44-2.el7.centos.x86_64 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下载mysql的安装包&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ wget http://dev.mysql.com/Downloads/MySQL-5.6/MySQL-server-5.6.21-1.rhel5.x86_64.rpm
 $ wget http://dev.mysql.com/Downloads/MySQL-5.6/MySQL-devel-5.6.21-1.rhel5.x86_64.rpm
 $ wget http://dev.mysql.com/Downloads/MySQL-5.6/MySQL-client-5.6.21-1.rhel5.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装rpm软件包&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ rpm -ivh MySQL-****.rpm 	
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装MySQL-server会报一个错，因为缺少依赖，使用yum安装即可&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ yum install -y libaio
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初始化MySQL及设置密码&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ /usr/bin/mysql_install_db
 $ service mysql start
 $ cat /root/.mysql_secret  #查看root账号密码
 $ mysql -uroot -pAsTsb42   #AsTsb42是看到的密码
 mysql&amp;gt; SET PASSWORD = PASSWORD(&#39;123456&#39;);    #设置密码为123456
 mysql&amp;gt; exit
 $ mysql -uroot -p123456
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;远程登陆用户设置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; use mysql;
 mysql&amp;gt; select host,user,password from user;
 mysql&amp;gt; update user set password=password(&#39;123456&#39;) where user=&#39;root&#39;;
 mysql&amp;gt; update user set host=&#39;%&#39; where user=&#39;root&#39; and host=&#39;localhost&#39;;
 mysql&amp;gt; flush privileges;
 mysql&amp;gt; exit
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改mysql的配置文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ vi /etc/my.cnf.d/my-default.cnf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;加入如下内容：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [client]
 password=123456
 port=3306
 default-character-set=utf8
	
 [mysqld]
 port=3306
 character_set_server=utf8
 character_set_client=utf8
 collation_server=utf8_general_ci
 collation_database=utf8_general_ci
 lower_case_table_names=1
 max_connections=1000
	
 [mysql]
 default-character-set=utf8
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql的默认安装位置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; /var/lib/mysql/               #数据库目录
 /usr/share/mysql              #配置文件目录
 /usr/bin                      #相关命令目录
 /etc/init.d/mysql             #启动脚本
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql的启动和停止&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ service mysql stop
 $ service mysql start
 $ service mysql restart
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置开机自启动&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ chkconfig mysql on
 $ chkconfig --list | grep mysql
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mysql-1&quot;&gt;mysql基础信息（[]表示可选）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DBA和运维同学常用&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; -- 查看mysql版本信息
 select version(); 
		
 -- 查看字符集
 show variables like &#39;%collation%&#39;;
 show variables like &#39;%char%&#39;;	
	
 -- 查看是否打开二进制日志文件的功能	
 show variables like &#39;%log_bin%&#39;;

 -- 查看有哪些数据库	
 show databases;	

 -- 查看数据库中有哪些表			
 show tables from db_name;		

 -- 查看表的字段信息
 show COLUMNS from db_name.table_name

 -- 查看表的信息	
 show table status from db_name;		
	
 -- 查看MySQL本次启动后的运行时间(单位：秒)
 show status like &#39;uptime&#39;;
	
 -- 查看select语句的执行数
 show [global] status like &#39;com_select&#39;;
	
 -- 查看insert语句的执行数
 show [global] status like &#39;com_insert&#39;;
	
 -- 查看update语句的执行数
 show [global] status like &#39;com_update&#39;;
	
 -- 查看delete语句的执行数
 show [global] status like &#39;com_delete&#39;;
	
 -- 查看试图连接到MySQL(不管是否连接成功)的连接数
 show status like &#39;connections&#39;;
	
 -- 查看线程缓存内的线程的数量。
 show status like &#39;threads_cached&#39;;
	
 -- 查看当前打开的连接的数量。
 show status like &#39;threads_connected&#39;;
	
 -- 查看当前打开的连接的数量。
 show status like &#39;threads_connected&#39;;
	
 -- 查看创建用来处理连接的线程数。
 -- 如果Threads_created较大，你可能要增加thread_cache_size值。
 show status like &#39;threads_created&#39;;
	
 -- 查看激活的(非睡眠状态)线程数。
 show status like &#39;threads_running&#39;;
	
 -- 查看立即获得的表的锁的次数。
 show status like &#39;table_locks_immediate&#39;;
	
 -- 查看不能立即获得的表的锁的次数。
 -- 如果该值较高，并且有性能问题，你应首先优化查询，然后拆分表或使用复制。
 show status like &#39;table_locks_waited&#39;;
	
 --查看创建时间超过slow_launch_time秒的线程数。
 show status like &#39;slow_launch_threads&#39;;
	
 --查看查询时间超过long_query_time秒的查询的个数。
 show status like &#39;slow_queries&#39;;
	
 -- 查看慢查询日志功能是否开启
 show variables like &#39;%slow%&#39;;

 -- 多长时间才是慢查询
 show variables like &#39;%long%&#39;;

 -- 设置查询超过1秒就是慢查询
 set session long_query_time=1;

 -- 查看日志信息是输出到数据库还是系统文件(FILE为系统文件)
 show variables like &#39;log_output&#39;;

 -- 查看发生了多少次慢查询
 show global status like &#39;Slow_queries&#39;;

 -- 将所有没有使用到索引的sql语句都记录到慢查询日志中
 set global log_queries_not_using_indexes = true;

 -- 查看数据库文件的路径
 show variables like &quot;%datadir%&quot;;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 21 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://colorful.ren/mysql/2016/09/21/mysql.html</link>
        <guid isPermaLink="true">http://colorful.ren/mysql/2016/09/21/mysql.html</guid>
        
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>plantUML的使用</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;经常需要画一些图，比如类图，时序图，用例图等，最近接触到一款有趣的工具，是eclipse的一个插件:plantUML。这里只记录最基础的地方，以后再来完善&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;安装&lt;/h3&gt;
&lt;p&gt;直接访问 &lt;strong&gt;&lt;a href=&quot;http://plantuml.com/&quot;&gt;plantUML官网&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;问题&lt;/h3&gt;
&lt;p&gt;安装好插件之后，此时只能使用plantUML画一些时序图，并不能从类文件直接生成类图，这时候还需要安装和配置一个十分牛*的画图工具： &lt;strong&gt;&lt;a href=&quot;http://www.graphviz.org/&quot;&gt;Graphviz&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;graphviz&quot;&gt;Graphviz的使用&lt;/h3&gt;
&lt;p&gt;仅仅使用Graphviz就已经可以画图了，直接使用Graphedit.exe程序就可以画图了，具体参照官网。&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Sep 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/java/2016/09/20/plantuml.html</link>
        <guid isPermaLink="true">http://colorful.ren/java/2016/09/20/plantuml.html</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Object的equals和hashCode和clone方法</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Object类是Java中其他所有类的祖先，没有Object类Java面向对象无从谈起。作为其他所有类的基类，Object具有哪些属性和行为，是Java语言设计背后的思维体现。
Object类位于java.lang包中，java.lang包包含着Java最基础和核心的类，在编译时会自动导入。Object类没有定义属性，一共有13个方法,这里我重点记录3个方法：equals,hashCode,clone，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;equals&quot;&gt;equals方法&lt;/h3&gt;
&lt;p&gt;==与equals在Java中经常被使用，大家也都知道==与equals的区别：  &lt;br /&gt;
==表示的是变量值完成相同（对于基础类型，地址中存储的是值，引用类型则存储指向实际对象的地址）；  &lt;br /&gt;
equlas()方法的正确理解应该是：判断两个对象是否相等。那么判断对象相等的标尺又是什么？在object类中，此标尺即为==。当然，这个标尺不是固定的，其他类中可以按照实际的需要对此标尺含义进行重定义。如String类中则是依据字符串内容是否相等来重定义了此标尺含义。如此可以增加类的功能型和实际编码的灵活性。当然了，如果自定义的类没有重写equals()方法来重新定义此标尺，那么默认的将是其父类的equals()，直到object基类。&lt;/p&gt;

&lt;p&gt;需要注意如果equals重写了，hashCode方法也应该重写，而且当equals为真，hashCode值应该一致，这是最佳实践，也是通用协定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Aktf9sH.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;以上是节选自JDK文档中的描述。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;hashcode&quot;&gt;hashCode方法&lt;/h3&gt;
&lt;p&gt;hashCode()方法返回一个整形数值，表示该对象的哈希码值。
hashCode()具有如下约定：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在Java应用程序程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致。&lt;/li&gt;
  &lt;li&gt;如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等。&lt;/li&gt;
  &lt;li&gt;反之，两个对象调用hasCode()返回的哈希码相等，这两个对象不一定相等。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;可能有人在此产生疑问：既然比较两个对象是否相等的唯一条件（也是冲要条件）是equals，那么为什么还要弄出一个hashCode()，并且进行如此约定，弄得这么麻烦？&lt;/li&gt;
    &lt;li&gt;其实，这主要体现在hashCode()方法的作用上，其主要用于增强哈希表的性能。
以集合类中，以Set为例，当新加一个对象时，需要判断现有集合中是否已经存在与此对象相等的对象，如果没有hashCode()方法，需要将Set进行一次遍历，并逐一用equals()方法判断两个对象是否相等，此种算法时间复杂度为o(n)。通过借助于hasCode方法，先计算出即将新加入对象的哈希码，然后根据哈希算法计算出此对象的位置，直接判断此位置上是否已有对象即可。（注：Set的底层用的是Map的原理实现）&lt;/li&gt;
    &lt;li&gt;在此需要纠正一个理解上的误区：对象的hashCode()返回的不是对象所在的物理内存地址。甚至也不一定是对象的逻辑地址，hashCode()相同的两个对象，不一定相等，换言之，不相等的两个对象，hashCode()返回的哈希码可能相同。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;clone&quot;&gt;clone方法&lt;/h3&gt;
&lt;p&gt;clone方法虽然使用的不多，但是如果需要重复创建多个相同对象的时候，可以使用这个方法，使用方法也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return super.clone();//这里返回的是一个Object类型的，需要依据实际情况进行转型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用clone方法，需要注意的一点是：clone的对象，如果有有引用类型的属性，是需要深度克隆的，否则，clone的对象和原对象是的属性引用指向的是相同的实例。&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Sep 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/java/2016/09/06/java-equals-hashcode.html</link>
        <guid isPermaLink="true">http://colorful.ren/java/2016/09/06/java-equals-hashcode.html</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>java集合备忘录</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;java集合的运用和认识的深入程度是一个java程序员水平的重要体现，但是要想把这一部分的内容理解透彻，深刻掌握是需要整理和总结的。以前总结过，但是没有形成文字，时间长了难免会忘记，现在记录在此。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;java&quot;&gt;java集合的总体框架&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/j6gYadi.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;java集合类框架有两个顶层接口,有多个子接口和抽象类，若干实现类。这些接口和类可以抽象的分成2类：一类是”序列”,一类是”键值对”。其实就是下面这两类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java.util.Collection
java.util.Map
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们不讨论抽象类，直接说实现类。  &lt;br /&gt;
Collection的具体实现分成两部分：List相关的和Set相关的。List和Set都是接口。两者最大的区别就是元素是否唯一。List是不唯一的，Set是唯一的。  &lt;br /&gt;
List的具体实现有下面几种:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayList
LinkedList
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;ArrayList是一个数组队列，相当于动态数组。它是由数组实现的，随机访问效率高，随机插入，删除效率低&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;LinkedList是一个双向链表。它可以被当做堆栈，队列或者双向队列进行操作。随机访问效率低，但是插入、删除效率高&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;ArryList和LinkedList都不是线程安全的，想要线程安全，可以使用Collections.synchronizedList(List list)进行处理&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;List当然还有其他的实现类，比如：Vector，Stack。这些因为比较&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 24 Aug 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/java/2016/08/24/javacollection.html</link>
        <guid isPermaLink="true">http://colorful.ren/java/2016/08/24/javacollection.html</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>SSH的点点滴滴</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;以前看电影，黑客们在一个黑乎乎的界面的噼里啪啦一顿狂敲，往往能解决一个严重的问题，那个黑乎乎的界面上看上去是那么高端。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;ssh&quot;&gt;什么是SSH&lt;/h4&gt;

&lt;h4 id=&quot;ssh-1&quot;&gt;常用的SSH工具有哪些怎样选择&lt;/h4&gt;

</description>
        <pubDate>Wed, 10 Aug 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/linux/2016/08/10/ssh.html</link>
        <guid isPermaLink="true">http://colorful.ren/linux/2016/08/10/ssh.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>成熟</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;什么是成熟&lt;/h3&gt;

&lt;blockquote&gt;

  &lt;p&gt;一种明亮而不刺眼的光辉&lt;br /&gt;
一种圆润而不腻耳的音响&lt;br /&gt;
一种不需要对别人察言观色的从容&lt;br /&gt;
一种终于停止向周围申诉求告的大气&lt;br /&gt;
一种不理会哄闹的微笑&lt;br /&gt;
一种洗刷了偏激的淡漠&lt;br /&gt;
一种无须伸张的厚实&lt;br /&gt;
一种并不陡峭的高度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是我在公司的一次培训的教材上看到的文字，后来经过多方查找发现这段文字出自著名作家&lt;em&gt;余秋雨&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;当时看到这段话，有一种豁然开朗，恍然大悟的感觉。是啊，真正的成熟就是作者描述的这样：平和，温润，但又充满力量。&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Feb 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/fulin/2016/02/25/grow.html</link>
        <guid isPermaLink="true">http://colorful.ren/fulin/2016/02/25/grow.html</guid>
        
        
        <category>fulin</category>
        
      </item>
    
      <item>
        <title>asList的使用及异常问题</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;导语&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;最近遇到一个问题，以前也遇到过，当时没有深入研究就没有记录下来，时间长了，忘记了，今天又再次遇到，这个问题表面上看很简单，其实不简单，今天记录在案，防止以后再次发生…&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;问题是这样的，将数组转成List，通常我们习惯这样写成:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;1&quot;,&quot;2&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是我们这样就得到了一个&lt;strong&gt;list&lt;/strong&gt;,但是这个List的实现类是&lt;strong&gt;java.util.Arrays.ArrayList&lt;/strong&gt;(而不是java.util.ArrayList)。&lt;/p&gt;

&lt;p&gt;这里需要注意这两个同名但是不同包的类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java.util.Arrays.ArrayList
java.util.ArrayList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;剖析JDK源代码可以发现:java.util.Arrays.ArrayList继承了java.util.AbstractList这个类，再来看看java.util.AbstractList类是啥样子的？可以发现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public E set(int index, E element)
public E set(int index, E element)
public E remove(int index)
public void add(int index, E element)  | public boolean add(E e)调用add(int index, E element)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上方法的实现全部是抛出UnsupportedOperationException异常。因此有Arrays.asList转换出来的List他其实是一个AbstractList他可以像List一样访问，但是不可其做任何修改操作。&lt;/p&gt;

&lt;p&gt;这也说明了，为什么Arrays.asList出来的List，对其做add、remove操作为抛出UnsupportedOperationException异常。&lt;/p&gt;

&lt;p&gt;换句话说，其实java.util.Arrays.ArrayList其实只是对数组做了一个装饰，可以看到里面的实现，E get(int index)、E set(int index, E element)等方法都是对数组的操作，他的目的只是提供了可以像访问List那样来访问数组而已。&lt;strong&gt;本质上其实还是一个数组。&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 20 Feb 2016 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/fulin/2016/02/20/aslist.html</link>
        <guid isPermaLink="true">http://colorful.ren/fulin/2016/02/20/aslist.html</guid>
        
        
        <category>fulin</category>
        
      </item>
    
      <item>
        <title>如何当好项目小组长</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;   从今年开始，我开始带团队了，在公司的项目管理平台上，我的角色是“研发经理”。
和其他3个兄弟并肩作战，负责维护和开发公司的一个有5年历史的老系统，在工作的过程中遇到了很多的问题。
   让我很困扰,这里记录一下遇到的问题，和自己的解决方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;问题&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;	1,团队成员对系统的业务逻辑不是很清晰
	2,需求很急，产品部经常一次提出很多需求
	3,由于工作强度大，团队成员抱怨很多。
	4,自己以前是搞Java的，但是这个系统是用php写的，自己也不熟悉
	5,需求经常变更
	6,自己要与多个部门的人沟通，一天下来，经常是累的不行
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;解决办法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;	1,当接手一个新的项目，尤其是一个老系统。这时候，需要尽快，尽可能的理清楚系统的业务逻辑，能理多少是多少。
    2，对此，我总结出的一个方法是：从用户入手，分析主要用户的主要业务逻辑。
	3，形成一个流程图，用自己最擅长的方式来做，跟别人沟通的时候，用这个图说事，来的更快。
	4，从一个熟悉的技术，转向不熟悉的技术，没有别的捷径，需要自己利用下班时间来学习，以解决实际问题为前提。
	5，合理规划需求实现的周期，不能全盘向产品妥协。
	6，对待需求变更，这个是考验自己需求管理能力了，有时候，一个excel表比自己的记忆要好很多。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以前自己专心的写代码，现在突然让我来带团队，多少还是有点不习惯，首先是思维方式变了，以前自己专注于自己的逻辑和技术，现在需要自己具备更广的视野和知识储备。对自己的沟通能力也是一个很大的考验。
我需要不断的总结和摸索。&lt;/p&gt;

</description>
        <pubDate>Tue, 01 Dec 2015 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/fulin/2015/12/01/leader.html</link>
        <guid isPermaLink="true">http://colorful.ren/fulin/2015/12/01/leader.html</guid>
        
        
        <category>fulin</category>
        
      </item>
    
      <item>
        <title>与ruby有关的笔记</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;背景&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;	ruby这几年的名气越来越大了，甚至传说ruby是进行web开发效率最高的语言。前段
时间折腾自己的github个人博客，接触到jekyll，进而接触到ruby，就稍微了解了一下。
感觉ruby跟python和node这两种语言非常接近。
	这里记一下自己了解到的一点点有限的知识，防止遗忘。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;rubygem&quot;&gt;ruby的包管理工具:gem&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;	像ruby，pyhon,node这几种语言都有自己的包管理工具，用起来真的感觉非常的爽，
唯一不好的地方是：有时候下载的网速太慢了。遇到这种情况，就需要更换源。
	gem -v 										#gem版本
	gem source 									#gem资源
	gem sources -a url ｜gem sources -r url 	   	#gem添加或删除配置源
	gem update 									#更新所有包
	gem update --system 							#更新RubyGems软件
	gem install rake 							#安装rake,从本地或远程服务器
	gem install rake --remote 					#安装rake,从远程服务器
	gem install watir -v(或者--version) 1.6.2	#指定安装版本的
	gem uninstall rake 							#卸载rake包
	gem list d 									#列出本地以d打头的包
	gem query -n &#39;&#39;[0-9]&#39;&#39; --local 				#查找本地含有数字的包
	gem search log --both 						#从本地和远程服务器上查找含有log字符串的包
	gem search log --remoter 					#只从远程服务器上查找含有log字符串的包
	gem search -r log 							#只从远程服务器上查找含有log字符串的包
	gem help 									#提醒式的帮助
	gem help install							#列出install命令 帮助
	gem help examples 							#列出gem命令使用一些例子
	gem build rake.gemspec 						#把rake.gemspec编译成rake.gem
	gem check -v pkg/rake-0.4.0.gem 				#检测rake是否有效
	gem cleanup 								#清除所有包旧版本，保留最新版本
	gem contents rake	 						#显示rake包中所包含的文件
	gem dependency rails -v 0.10.1 				#列出与rails相互依赖的包
	gem environment 							#查看gem的环境
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ruby&quot;&gt;将ruby的源更换为淘宝的源&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ gem sources --remove http://rubygems.org/ 
$ gem sources -a http://ruby.taobao.org/  
$ gem sources -l  
*** CURRENT SOURCES ***  
  
http://ruby.taobao.org  
# 请确保只有 ruby.taobao.org  这时候就可以安装jekyll包了
$ gem install jekyll  #安装jekyll包  
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 20 Nov 2015 13:07:11 +0800</pubDate>
        <link>http://colorful.ren/ruby/2015/11/20/ruby.html</link>
        <guid isPermaLink="true">http://colorful.ren/ruby/2015/11/20/ruby.html</guid>
        
        
        <category>ruby</category>
        
      </item>
    
  </channel>
</rss>
