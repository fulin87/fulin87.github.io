<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>GIT笔记</title>
  <meta name="description" content="目录">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/tools/2015/03/10/git%E7%AC%94%E8%AE%B0.html">
  <link rel="alternate" type="application/rss+xml" title="fulin87的笔记" href="http://yourdomain.com/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">fulin87的笔记</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">GIT笔记</h1>
    <p class="post-meta"><time datetime="2015-03-10T00:00:00+08:00" itemprop="datePublished">Mar 10, 2015</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="section">目录</h2>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">目录</a></li>
  <li><a href="#git" id="markdown-toc-git">GIT安装</a></li>
  <li><a href="#git-1" id="markdown-toc-git-1">GIT介绍</a></li>
  <li><a href="#git-2" id="markdown-toc-git-2">GIT常用命令</a></li>
</ul>

<h2 id="git">GIT安装</h2>
<p>window: <a href="http://msysgit.github.io/">msysgit</a>
linux: yum install git
企业级GIT服务端: Stash</p>

<h2 id="git-1">GIT介绍</h2>
<p>git定下一种分支模型，在这种模型中，分支有两类，五种</p>

<p>永久性分支</p>

<ul>
  <li>master branch：主分支</li>
  <li>develop branch：开发分支</li>
</ul>

<p>临时性分支</p>

<ul>
  <li>feature branch：功能分支</li>
  <li>release branch：预发布分支</li>
  <li>hotfix branch：bug修复分支</li>
</ul>

<p>master：主分支从项目一开始便存在，它用于存放经过测试，已经完全稳定代码；在项目开发以后的任何时刻当中，master存放的代码应该是可作为产品供用户使用的代码。所以，应该随时保持master仓库代码的清洁和稳定，确保入库之前是通过完全测试和代码reivew的。master分支是所有分支中最不活跃的，大概每个月或每两个月更新一次，每一次master更新的时候都应该用git打上tag，说明你的产品有新版本发布了。</p>

<p>develop：开发分支，一开始从master分支中分离出来，用于开发者存放基本稳定代码。之前说过，每个开发者的仓库相当于源仓库的一个镜像，每个开发者自己的仓库上也有master和develop。开发者把功能做好以后，是存放到自己的develop中，当测试完以后，可以向管理者发起一个pull request，请求把自己仓库的develop分支合并到源仓库的develop中。所有开发者开发好的功能会在源仓库的develop分支中进行汇总，当develop中的代码经过不断的测试，已经逐渐趋于稳定了，接近产品目标了。这时候，我们就可以把develop分支合并到master分支中，发布一个新版本。</p>

<p>feature：功能性分支，是用于开发项目的功能的分支，是开发者主要战斗阵地。开发者在本地仓库从develop分支分出功能分支，在该分支上进行功能的开发，开发完成以后再合并到develop分支上，这时候功能性分支已经完成任务，可以删除。功能性分支的命名一般为feature-<em>，</em>为需要开发的功能的名称。</p>

<p>release：预发布分支，当产品即将发布的时候，要进行最后的调整和测试，这时候就可以分出一个预发布分支，进行最后的bug fix。测试完全以后，发布新版本，就可以把预发布分支删除。预发布分支一般命名为release-*。</p>

<p>hotfix：修复bug分支，当产品已经发布了，突然出现了重大的bug。这时候就要新建一个hotfix分支，继续紧急的bug修复工作，当bug修复完以后，把该分支合并到master和develop以后，就可以把该分支删除。修复bug分支命名一般为hotfix-*</p>

<h2 id="git-2">GIT常用命令</h2>
<p>从现有仓库克隆: 
git clone https://github.com/Motang/webside.git newFolderName</p>

<p>检查当前文件状态: 
git status</p>

<p>暂存已修改文件：
git add   把目标文件快照放入暂存区域</p>

<p>忽略某些文件: 
cat .gitignore *.[oa] *~  第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件</p>

<p>查看已暂存和未暂存的更新:
git diff 不过是显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异
git diff –cached 看已经暂存起来的文件和上次提交时的快照之间的差异</p>

<p>git status查看一下状态</p>

<p>提交更新
git commit -m “just for testing”     -m 参数后跟提交说明的方式, 默认提交暂存区域已经准备妥当的更改
git commit -a -m “just for testing”  加上-a 选项，Git 就会自动把所有已经跟踪过的文件和暂存起来的一并提交</p>

<p>我们把文件往Git版本库里添加的时候，是分两步执行的：
第一步是用“git add”把文件添加进去，实际上就是把文件修改添加到暂存区；
第二步是用“git commit”提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>

<p>回到规定的版本
git reset –hard commit_id 用来回到规定的版本 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭
在Git中，用HEAD表示当前版本，也就是最新的提交“ 3628164…882e1e0”（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。
git reset –hard HEAD~</p>

<p>移除文件
git rm          从已跟踪文件清单中移除（确切地说，是从暂存区域移除）
git rm –cached readme.txt 把文件从暂存区域移除中删除</p>

<p>移动文件
git mv file_from file_to   当于运行了下面三条命令： $ mv README.txt README $ git rm README.txt $ git add README</p>

<p>查看提交历史
git log -p  选项-p展开显示每次提交的内容差异
git log –graph
用git log可以查看提交历史，以便确定要回退到哪个版本。git log –pretty=oneline
用git reflog查看命令历史，以便确定要回到未来的哪个版本</p>

<p>撤消操作
git reset HEAD benchmarks.rb 现在 benchmarks.rb 文件又回到了之前已修改未暂存的状态
git commit –amend  相当于git commit -m ‘initial commit’ $ git add forgotten_file $ git commit –amend</p>

<p>git checkout – file 慎用，该文件已经恢复到修改前的版本。你可能已经意识到了，这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过 来重写了此文件
场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。
场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。
场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>

<p>从远程仓库抓取数据
git fetch [remote-name] 此命令会到远程仓库中拉取所有你本地仓库中还没有的数据
git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。</p>

<p>git branch  列出本地分支
git branch -r 列出远程的分支</p>

<p>分支删除
git branch -d name 
git branch -D name 强行删除</p>

<p>查看分支：git branch
创建分支：git branch name
切换分支：git checkout name
创建+切换分支：git checkout -b name
合并某分支到当前分支：git merge name
删除分支：git branch -d name
创建分支: git branch  本地分支名 远程分支名
创建分支并切换到此分支: git checkout -b 本地分支名 远程分支名</p>

<p>git branch –set-upstream dev origin/dev
master分支是主分支，因此要时刻与远程同步；
dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；
bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；
feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>

<p>删除远程分支
git branch -r -d origin/branch-name
git push origin :branch-name 冒号前面的空格不能少，原理是把一个空分支push到server上，相当于删除该分支</p>

<p>推送数据到远程仓库
git push remote-name branch-name 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支
git push origin master 如果要把本地的master分支推送到origin服务器上（再次说明下，克隆操作会自动使用默认的master和origin名字</p>

<p>查看远程仓库信息
git remote show [remote-name] 查看某个远程仓库的详细信息
git remote -v显示更详细的信息</p>

<p>远程仓库的删除和重命名
git remote rename 命令修改某个远程仓库在本地的简短名称
git remote rename pb paul $git remote origin paul 把pb改成paul,接着重新获取</p>

<p>合并分支
git merge feature1 将分支feature1合并到当前分支
git merge –no-ff -m “merge with no-ff” dev 合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并
　　合并操作将两条或多条分支合并到一起，实际上有好几种分支合并方法，下面介绍主要的三种：</p>

<p>合并1. 直接合并(straight merge)：把两条分支上的历史轨迹合并，交汇到一起。
　　比如要把dev分支上的所有东东合并到master分支： 首先先到master分支：git checkout master 然后把dev给合并过来：git merge dev  注意没参数的情况下merge是fast-forward的，即Git将master分支的指针直接移到dev的最前方。
　　换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单移动指针，所以这种合并成为快进式(Fast-forward)。</p>

<p>合并2. 压合合并(squashed commits)：将一条分支上的若干个提交条目压合成一个提交条目，提交到另一条分支的末梢。把dev分支上的所有提交压合成主分支上的一个提交，即压合提交：
　　git checkout master
　　git merge –squash dev
　　此时，dev上的所有提交已经合并到当前工作区并暂存，但还没有作为一个提交，可以像其他提交一样，把这个改动提交到版本库中：
　　git commit –m “something from dev”　　</p>

<p>合并3. 拣选合并(cherry-picking)：拣选另一条分支上的某个提交条目的改动带到当前分支上。每一次提交都会产生一个全局唯一的提交名称，利用这个名称就可以进行拣选提交。
　　比如在dev上的某个提交叫：321d76f
　　把它合并到master中：
　　git checkout master
　　git cherry-pick 321d76f
　　要拣选多个提交，可以给git cherry-pick命令传递-n选项，比如：
　　git cherry-pick –n 321d76f
　　这样在拣选了这个改动之后，进行暂存而不立即提交，接着可以进行下一个拣选操作，一旦拣选完需要的各个提交，就可以一并提交。</p>

<p>冲突处理
　　当两条分支对同一个文件的同一个文本块进行了不同的修改，并试图合并时，Git不能自动合并的，称之为冲突(conflict)。解决冲突需要人工处理。
　　比如当前在master分支，想把dev分支merge过来，结果产生了一个冲突，打开文件内容可以看到这么一个冲突：</p>

<p><code>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
test in master
=======
test in dev
&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev
</code></p>

<p>　　«««&lt;标记冲突开始，后面跟的是当前分支中的内容。
　　HEAD指向当前分支末梢的提交。
　　=======之后，»»»&gt;之前是要merge过来的另一条分支上的代码。
　　»»»&gt;之后的dev是该分支的名字。
　　对于简单的合并，手工编辑，然后去掉这些标记，最后像往常的提交一样先add再commit即可。</p>

<p>查看远程库信息，使用git remote -v；
本地新建的分支如果不推送到远程，对其他人就是不可见的；
从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；
在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；
建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；
从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>

<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue -101来修复它，但是，等等，当前正在dev上进行的工作还没有提交，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作
git stash 
git stash list
git stash pop 恢复的同时把stash内容也删了
git stash apply 恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除</p>

<p>标签
git tag 列显已有的标签
git tag v1.3 v1.4 用特定的搜索模式列出符合条件的标签
git show v1.4 命令查看相应标签的版本信息
git tag -a v1.4 -m ‘my version 1.4’ 新建含附注的标签，-a指定标签名字，-m选项则指定了对应的标签说明
git tag -s v1.5 -m ‘my signed 1.5 tag 新建签署标签,如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s
git tag v1.4-lw 新建轻量级标签
git push origin [tagname] 新建分享标签,默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库,如果要一次推送所有本地新增的标签上去，可以使用 –tags 选项
git push origin –tags 一次推送所有本地新增的标签上去，可以使用 –tags 选项
git push origin :refs/tags/v0.9 远程删除
git tag -v [tag-name] 此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证
git tag -a v1.2 9fceb02 后期加注标签
git tag -d tag-name 删除标签</p>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">fulin87的笔记</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>fulin87的笔记</li>
          <li><a href="mailto:your-email@domain.com">your-email@domain.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/fulin87"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">fulin87</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/fulin87"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">fulin87</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>唯天下之至诚，胜天下之至伪；唯天下之至拙，胜天下之至巧。
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
